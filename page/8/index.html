<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Solar">
<meta property="og:url" content="https://zhangchenchen.github.io/page/8/index.html">
<meta property="og:site_name" content="Solar">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Solar">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhangchenchen.github.io/page/8/"/>





  <title> Solar </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-92407570-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Solar</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/11/10/make-nfs-as-cinder-backend/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/10/make-nfs-as-cinder-backend/" itemprop="url">
                  openstack系列--设置nfs作为cinder backend
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-10T13:06:25+08:00">
                2016-11-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/10/make-nfs-as-cinder-backend/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/11/10/make-nfs-as-cinder-backend/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">nfs 设置</a></p>
<p><a href="#B">修改cinder 配置文件 </a></p>
<p><a name="A"></a></p>
<h2 id="nfs-设置"><a href="#nfs-设置" class="headerlink" title="nfs 设置"></a>nfs 设置</h2><p>首先对nfs进行设置，大体以下几个步骤：</p>
<ul>
<li><p>磁盘分区，格式化磁盘<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161110-fdisk.png" alt="fdisk"><br>在格式化磁盘的时候出现如下错误：<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161110-mkfswrong.png" alt="mkfswrong"><br>搜了很长时间没找到答案，看提示应该是系统还有什么进程在使用这块磁盘，后请教别人后发现该磁盘之前做过ceph的osd盘，虽然已经删除了对应的关联，但是并没有删除完全，必须将/var/lib/ceph/osd/下对应的ceph包删除。<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161110ceph.png" alt="ceph osd"><br>然后，格式化成功。<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161110mkfsright.png" alt="mkfs"></p>
</li>
<li><p>新建共享目录，mount 磁盘<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161111mount-file.png" alt="mount file"></p>
</li>
<li>nfs安装 先查看有没有安装<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161111nfs-install.png" alt="nfs-install"></li>
<li>配置nfs共享文件路径并启动nfsserver.<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161111nfs-config.png" alt="nfs-config"></li>
</ul>
<p><a name="B"></a></p>
<h2 id="修改cinder-配置文件"><a href="#修改cinder-配置文件" class="headerlink" title="修改cinder 配置文件"></a>修改cinder 配置文件</h2><ul>
<li><p>首先修改cinder配置文件cinder.conf，指定nfsshare文件路径(图中注释部分为之前的ceph配置)<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161110cinder-config.png" alt="cinder-config"></p>
</li>
<li><p>添加nfsshare 文件，只需要指出nfs暴露的接口即可。<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161110-nfsshare.png" alt="nfsshare"></p>
</li>
<li>重启cinder-volume</li>
<li>发现cinder volume报错，发现是cinder对挂载的nfs没有权限，修改nfs挂载文件的user,group 为cinder，或者直接chmod 777 (不安全)</li>
<li>重启cinder-volume，成功。</li>
<li>查看mount验证下。<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161111-mount-nfs.png" alt="mount verify"></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://wiki.jikexueyuan.com/project/learn-linux-step-by-step/disk-partition-format-and-test.html" target="_blank" rel="noopener">磁盘分区，格式化与检验</a></p>
<p><a href="http://www.centoscn.com/CentosSecurity/SoftSecurity/2015/0408/5118.html" target="_blank" rel="noopener">CentOS 6.5下NFS安装配置</a><br><a href="http://docs.openstack.org/admin-guide/blockstorage-nfs-backend.html" target="_blank" rel="noopener">Configure an NFS storage back end</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/11/03/2016-11-3-intro-to-salt/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/03/2016-11-3-intro-to-salt/" itemprop="url">
                  devops系列-- 运维利器SaltStalk介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-03T13:06:25+08:00">
                2016-11-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/03/2016-11-3-intro-to-salt/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/11/03/2016-11-3-intro-to-salt/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="A"></a></p>
<h2 id="SaltStalk是什么"><a href="#SaltStalk是什么" class="headerlink" title="SaltStalk是什么"></a>SaltStalk是什么</h2><p>salt官网给出的介绍简洁明了：</p>
<ul>
<li>一个配置管理系统，能够维护预定义状态的远程节点(比如，确保指定的报被安装，指定的服务在运行)</li>
<li>一个分布式远程执行系统，用来在远程节点（可以是单个节点，也可以是任意规则挑选出来的节点）上执行命令和查询数据。开发其的目的是为远程执行提供最好的解决方案，并使远程执行变得更好，更快，更简单。</li>
</ul>
<p>其实，除了saltstack,还有其他的同类型软件供我们选择，比如puppet、chef、ansible、fabric等,关于其中的区别以及优劣势可以参考这里，<a href="http://blog.takipi.com/deployment-management-tools-chef-vs-puppet-vs-ansible-vs-saltstack-vs-fabric/" target="_blank" rel="noopener">Ansible vs. Chef vs. Fabric vs. Puppet vs. SaltStack</a><br>稍微总结下：chef,puppet 是出现时间比较早的系统，对于比较重视成熟性和稳定性的公司来说比较合适。ansible与saltstack比较适合快速灵活的生产部署环境，且适合没有太多额外要求，生产环境操作系统一致的情况下。fabric比较适合规模比较小的环境，属于入门级别的配置管理系统。</p>
<p>这里有一个视频更细粒度的（可用性，互操作性，扩展性等）比较了一下，<a href="https://www.youtube.com/watch?v=OmRxKQHtDbY&amp;t=1060s" target="_blank" rel="noopener">Chef vs Puppet vs Ansible vs SaltStack | Configuration Management Tools Comparison </a></p>
<p><a name="B"></a></p>
<h2 id="SaltStalk-安装"><a href="#SaltStalk-安装" class="headerlink" title="SaltStalk 安装"></a>SaltStalk 安装</h2><p>安装比较简单，<a href="http://docs.saltstack.cn/topics/installation/index.html" target="_blank" rel="noopener">check this</a>,不再赘述。</p>
<p><a name="C"></a></p>
<h2 id="SaltStalk-配置"><a href="#SaltStalk-配置" class="headerlink" title="SaltStalk 配置"></a>SaltStalk 配置</h2><p>saltstalk是典型的CS架构，主要分两种角色，master和minions,master负责minions的配置管理以及远程执行。一般来说，master的配置文件位于/etc/salt/master，minion的配置文件在相应机器的/etc/salt/minion,只需在minion配置文件中指定master指向即可运行。</p>
<p><a href="http://docs.saltstack.cn/ref/configuration/master.html" target="_blank" rel="noopener">master的配置项</a>非常多，大致包括以下几项：</p>
<ul>
<li>主要配置：包括网络接口，提供服务的端口，master id,最大打开文件数，工作线程个数，返回端口，缓存目录，各种缓存配置（minions数据缓存，作业缓存等）</li>
<li>master 安全相关配置：主要是针对PKI验证的一些配置。</li>
<li>master模块管理相关配置</li>
<li>master state system 相关配置</li>
<li>pillar 相关配置</li>
<li>日志相关配置</li>
<li>windows软件源相关配置</li>
</ul>
<p><a href="http://docs.saltstack.cn/ref/configuration/minion.html" target="_blank" rel="noopener">minion的配置项</a>跟master大致类似，不再赘述。</p>
<p>其他：</p>
<ul>
<li>新版saltstack 中minion有一个minion_blackout的配置，该选项设为true后，该minion不会执行除saltutil.refresh_pillar之外的其他所有命令。</li>
<li>saltstack有一个访问控制系统对于非admin用户进行细粒度的访问控制。<a href="http://docs.saltstack.cn/topics/eauth/access_control.html" target="_blank" rel="noopener">check this</a></li>
<li>job管理器：可以实现对minion job的发送信号，定时调度等</li>
<li>job 返回数据管理：系统默认返回数据存储在Job cache（默认是在/var/cache/salt/master/jobs目录）中，还有其他两种存储模式：一种是External Job Cache，如下图</li>
</ul>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161107external-job-cache.png" alt="External Job Cache"></p>
<p>另一种是Master Job Cache，如下图：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161107master-job-cache.png" alt="Master Job Cache"></p>
<ul>
<li>returner: 我们可以在master端执行远程指令时指定returner,这样minion返回的数据不仅会返回到master，也会返回到我们指定的returner。而且我们也可以按照要求实现一个returner，来替换我们的Default Job Cache。</li>
</ul>
<p><a name="D"></a></p>
<h2 id="SaltStalk-一些概念解释"><a href="#SaltStalk-一些概念解释" class="headerlink" title="SaltStalk 一些概念解释"></a>SaltStalk 一些概念解释</h2><h3 id="sls-文件"><a href="#sls-文件" class="headerlink" title="sls 文件"></a>sls 文件</h3><p>salt state 文件的简称，saltstalk实现配置管理的核心部分，描述了系统的目标状态，一般遵循yaml格式，参考<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 语言教程</a>。</p>
<p>首先是配置管理的入口文件top.sls，默认在/srv/salt/目录下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">base:</span>          <span class="comment"># 默认环境变量</span></span><br><span class="line">  <span class="string">'*'</span><span class="string">:</span>         <span class="comment"># 通过正则进行匹配minion</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apache</span>    <span class="comment"># 需要自己写的state.sls模块名 </span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  my_group:</span>             <span class="comment">#通过分组名去进行匹配 须定义match:nodegroup</span></span><br><span class="line"><span class="attr">    - match:</span> <span class="string">nodegroup</span>  </span><br><span class="line"><span class="bullet">    -</span> <span class="string">nginx</span></span><br><span class="line"></span><br><span class="line">  <span class="string">'os:CentOs'</span><span class="string">:</span>        <span class="comment">#通过grains模块去匹配，须定义match:grain</span></span><br><span class="line"><span class="attr">    - match:</span> <span class="string">grain</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>再看下需要自己写的webserver.sls文件，默认位于/srv/salt/apache.sls。当然，还有其他组织形式，常用的还有/srv/salt/apache/init.sls 形式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apache:</span>           <span class="comment"># 标签定义</span></span><br><span class="line"><span class="attr">  pkg:</span>               <span class="comment"># 状态定义，这里使用（pkg state module）</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">installed</span>      <span class="comment"># 安装nginx（yum安装）</span></span><br><span class="line">  <span class="string">service.running:</span>   <span class="comment"># 保持服务是启动状态</span></span><br><span class="line"><span class="attr">    - enable:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">    - reload:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">    - require:</span></span><br><span class="line"><span class="attr">      - file:</span> <span class="string">/etc/init.d/httpd</span></span><br><span class="line"><span class="attr">    - watch:</span>                 <span class="comment">#检测下面配置文件，有变动，立马执行上述/etc/init.d/httpd 命令reload操作</span></span><br><span class="line"><span class="attr">      - file:</span> <span class="string">/etc/apache/httpd.conf</span></span><br><span class="line"><span class="attr">      - pkg:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>state 之间的逻辑关系一般有三种：</p>
<ul>
<li>require :依赖某个state，在运行此state前，先运行依赖的state，依赖可以有多个</li>
<li>watch :在某个state变化时运行此模块，watch除具备require功能外，还增了关注状态的功能.</li>
<li>order：优先级比require和watch低，有order指定的state比没有order指定的优先级高</li>
</ul>
<p>一般对某个minion执行具体state的时候，我们可以执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ salt minion-1 state.sls apache</span><br></pre></td></tr></table></figure></p>
<p>当然，如果是执行所有的sts文件，则是如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ salt minion-1 state.highstate   <span class="comment"># test=True 参数可以测试安装，并不真正安装</span></span><br></pre></td></tr></table></figure>
<h3 id="grain-vs-pillar-vs-mine"><a href="#grain-vs-pillar-vs-mine" class="headerlink" title="grain vs pillar vs mine"></a>grain vs pillar vs mine</h3><p>如果说sls文件是配置管理的骨架或框架的话，那么grain与pillar就是填充骨架的血与肉。其实他们就是saltstack自己定义的一些数据，通过这些数据定制我们的系统配置。</p>
<ul>
<li>grains 存储在minion一端，包括minion自己生成的一些信息，比如操作系统，内存，磁盘信息，cpu架构等等。当然我们也可以自己定制minion 的grains信息。通常做法是在默认/etc/salt/grains中定义。</li>
<li>pillar 是存储 在master端，完全是用户自定义的一些动态数据。一般存储在master端/srv/pillar 目录下。组织形式类似salt state。 </li>
<li>两者区别：一般来说，变化较少或不变的数据存储在grains中，一些敏感数据（如各种密码），易变数据，以及涉及到minion 配置的数据一般存储在pillar中。</li>
<li>mine 更像是以上两种形式的结合，它是定期从minions 收集的数据，传给master并存储在master端，这样，所有的minions都能获取到。mine数据是有时效性的，每隔一段时间便会更新。mine可以存储在mine配置文件中，不过更多的是将它放在pillar中，只需定义mine_functions 关键字即可。官网示例参考<a href="https://docs.saltstack.com/en/latest/topics/mine/index.html#example" target="_blank" rel="noopener">EXAMPLE</a></li>
</ul>
<p>两者的常用操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ salt <span class="string">'*'</span> grains.items   <span class="comment"># 查看所有 grains键值对</span></span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> grains.get os  <span class="comment"># 查看 grains中的 os对应的值</span></span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> saltutil.sync_grains <span class="comment"># 同步所有 grains数据</span></span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> pillar.items   <span class="comment"># 查看所有 pillar键值对</span></span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> pillar.get data  <span class="comment"># 查看 pillar中的 data对应的值</span></span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> saltutil.refresh_pillar <span class="comment"># 刷新所有 pilllar数据</span></span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> state.apply my_sls_file pillar=<span class="string">'&#123;"hello": "world"&#125;'</span> <span class="comment"># 命令行更改或增加pillar</span></span><br></pre></td></tr></table></figure>
<h3 id="execution-modules"><a href="#execution-modules" class="headerlink" title="execution modules"></a>execution modules</h3><p>也就是运程执行时需要 minions执行的函数，通常salt已经封装好了大量的modules,可以通过 salt ‘*’ sys.doc 查看所有modules的doc。当然也可以自己写modules，下文会给出示例。</p>
<h3 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h3><p>runner 本质是可定制化的Python 脚本，与execution modules 类似，不过是运行在master节点，可以使用salt-run 命令使用，非常方便（最新版的salt-run也可以运行modules 了，命令：salt-run salt.cmd test.ping ,）。<br>直接举个栗子：<br>首先指定runner脚本的位置，在master配置文件中指定：runner_dirs: [/srv/runner/]<br>然后就可以在指定目录下写Python 脚本了。</p>
<p>minions.py ：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import salt modules</span></span><br><span class="line"><span class="keyword">import</span> salt.client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Print a list of all of the minions that are up</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    client = salt.client.LocalClient(__opts__[<span class="string">'conf_file'</span>])</span><br><span class="line">    minions = client.cmd(<span class="string">'*'</span>, <span class="string">'test.ping'</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> minion <span class="keyword">in</span> sorted(minions):</span><br><span class="line">        <span class="keyword">print</span> minion</span><br></pre></td></tr></table></figure></p>
<p>使用命令行： salt-run minions.up  即可调用。<br>注：有两种模式，默认为同步模式，即有数据返回后才显示，还有一种异步模式，即立即返回不显示数据，可以指定returner将数据返回到指定容器中。</p>
<h3 id="salt-engines"><a href="#salt-engines" class="headerlink" title="salt engines"></a>salt engines</h3><p>salt engines 是一个利用salt 并独立长时间运行的进程。有以下特点：</p>
<ul>
<li>可以获取到salt的各种配置项，modules以及runner</li>
<li>以独立进程运行，由salt监视，一旦挂掉后由salt负责重启。</li>
<li>可以运行在master和minion上。</li>
</ul>
<p><a name="E"></a></p>
<h2 id="SaltStalk-使用"><a href="#SaltStalk-使用" class="headerlink" title="SaltStalk 使用"></a>SaltStalk 使用</h2><h3 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h3><p>saltstack 最基本的功能之一，在master节点实现对minions节点的远程控制与执行，命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ salt <span class="string">'&lt;target&gt;'</span> &lt;<span class="keyword">function</span>&gt; [arguments]</span><br></pre></td></tr></table></figure>
<ul>
<li>target 指定 minions,可以有多种方式匹配minions，正则匹配，group匹配，grains匹配，pillar匹配等。</li>
<li>function 就是前面讲的execution modules ，后面可以加参数。</li>
</ul>
<p>下面介绍下execution modules 的定制开发。<br>首先确定一下modules的位置，默认位于/srv/salt/_modules目录下，可以通过以下命令实现modules的同步。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ salt <span class="string">'*'</span> saltutil.sync_modules</span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> saltutil.sync_all</span><br><span class="line"></span><br><span class="line">$ salt <span class="string">'*'</span> state.apply</span><br></pre></td></tr></table></figure></p>
<p>通常modules的脚本会使用zip压缩文件，<a href="https://docs.saltstack.com/en/latest/ref/modules/index.html#creating-a-zip-archive-module" target="_blank" rel="noopener">官网示例</a></p>
<p>脚本中可以调用salt本身的module以及调用grains数据。同时注意str 类型 与unicode的转换。</p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>配置管理功能是在远程执行的基础上建立起来的，Salt 状态系统的核心是就是上面提到过的SLS文件。SLS表示系统将会是什么样的一种状态（比如安装什么服务，服务是否启动，服务配置等等），而且是以一种很简单的格式来包含这些数据。<br>下面是一个写SLS文件的示例：</p>
<ul>
<li>首先是在master配置文件中定义三个环境：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file_roots:</span><br><span class="line">  base:</span><br><span class="line">    - /srv/salt/prod</span><br><span class="line">  qa:</span><br><span class="line">    - /srv/salt/qa</span><br><span class="line">    - /srv/salt/prod</span><br><span class="line">  dev:</span><br><span class="line">    - /srv/salt/dev</span><br><span class="line">    - /srv/salt/qa</span><br><span class="line">    - /srv/salt/prod</span><br></pre></td></tr></table></figure>
<p>简单解释下：这里定义了三个环境，base环境就是生产环境，它只有一个salt根目录，qa环境可以获取到两个salt根目录下的配置文件，按照上下顺序优先采用 /srv/salt/qa 目录下的配置文件，dev环境同理。通常我们开发时，会首先在开发环境部署，新的SLS文件会存储在 /srv/salt/dev 环境中，然后将改变push到对应的开发机器。开发完成后，将新的SLS文件 复制到/srv/salt/qa 目录，push到对应的测试机器以供测试。最后测试完成后，才会把SLS文件复制到/srv/salt/prod 目录，push到生产环境的机器。</p>
<ul>
<li>接下来开始编写SLS文件了，首先编写各环境根目录下的top文件,因为 /srv/salt/prod目录下的文件是所有环境都能获取到的,所以只需在该目录下编写top文件即可。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">base:</span></span><br><span class="line">  <span class="string">'roles:prod'</span><span class="string">:</span></span><br><span class="line"><span class="attr">    - match:</span> <span class="string">grain</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">qa:</span></span><br><span class="line">  <span class="string">'roles:qa'</span><span class="string">:</span></span><br><span class="line"><span class="attr">    - match:</span> <span class="string">grain</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">dev:</span></span><br><span class="line">  <span class="string">'roles:dev'</span><span class="string">:</span></span><br><span class="line"><span class="attr">    - match:</span> <span class="string">grain</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apache</span></span><br></pre></td></tr></table></figure>
<p>这里我们是通过在 grain 中添加roles 键值对，然后通过grain进行匹配，当然也可以通过其他方法匹配（pillar,group，正则等）。apache是之后我们需要编写SLS文件，不过这在这之前，先在各minions 添加grain roles键值对。</p>
<ul>
<li>在对应minions 中添加grain roles键值对，默认编辑/etc/salt/grains ,添加 roles: prod 即可。添加完后，master 执行 salt ‘*’ saltutil.sync_grains 同步命令。</li>
<li>接下来开始编写apache的sls 文件。</li>
</ul>
<p>/srv/salt/prod/apache/init.sls<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apache:</span></span><br><span class="line">  <span class="string">pkg.installed:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">httpd</span></span><br><span class="line">  <span class="string">service.running:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">    - require:</span></span><br><span class="line"><span class="attr">      - pkg:</span> <span class="string">apache</span></span><br><span class="line"></span><br><span class="line"><span class="string">/var/www/html/index.html:</span></span><br><span class="line">  <span class="string">file.managed:</span></span><br><span class="line"><span class="attr">    - source:</span> <span class="attr">salt://apache/index.html</span></span><br><span class="line"><span class="attr">    - require:</span></span><br><span class="line"><span class="attr">      - pkg:</span> <span class="string">apache</span></span><br></pre></td></tr></table></figure></p>
<p>index.html 是我们的一个测试网页，放在/srv/salt/prod/apache/目录下。</p>
<ul>
<li><p>接下来在 master端执行 salt ‘*’ state.apply 命令 即可完成对应minions 端apache的安装，启动等工作。浏览器输入minion ip,可以查看到测试网页。</p>
</li>
<li><p>如果该过程中出现错误，多半是SLS文件写错了，可以查看 minion日志，如果日志不详细，可以先关掉salt-minion，然后运行 salt-minion -l debug ，再复现一次错误，便可查看到更详细日志。</p>
</li>
</ul>
<h3 id="event-reactor"><a href="#event-reactor" class="headerlink" title="event/reactor"></a>event/reactor</h3><p>event/reactor 是saltstack 中的两个系统。两者结合我们可以定制一些自动化的功能，比如，minion端的salt-minion服务重启后，master端立马同步grains，pillars信息。<br>event系统是一个本地的ZeroMQ PUB接口, 用于产生salt events.这个event总线是一个开放的系统,用于发送给Salt和其他系统发送关于操作的通告信息.event系统产生event有一个严格的标准. 每一个event有一个 tag . event tags用于快速过滤events. 每一个event有一个数据结构附加在tag后. 这个数据结构是个字典, 包含关于本event的信息。<br>reactor 系统会结合sls文件在master端去匹配event tags，匹配成功后执行相应的sls文件。</p>
<p>暂时还没有碰到此类需求，回头再看吧。</p>
<p><a name="F"></a></p>
<h2 id="SaltStalk-架构"><a href="#SaltStalk-架构" class="headerlink" title="SaltStalk 架构"></a>SaltStalk 架构</h2><p>关于架构部分，内容比较繁杂，通常会涉及到multimaster,multimaster with failover,salt-syndic等，后续有需求了再研究吧。</p>
<p>参考<a href="http://docs.saltstack.cn/topics/topology/index.html" target="_blank" rel="noopener">SALTSTACK ARCHITECTURE</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://docs.saltstack.com/en/latest/topics/using_salt.html" target="_blank" rel="noopener">saltstalk doc</a></p>
<p><a href="https://my.oschina.net/u/877567/blog/183959" target="_blank" rel="noopener">Saltstack SLS文件解读</a></p>
<p><a href="http://www.361way.com/salt-states/5350.html" target="_blank" rel="noopener">Saltstack自动化（五）sls文件使用</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/11/01/2016-11-1-keep-one-instance-in-a-machine/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/01/2016-11-1-keep-one-instance-in-a-machine/" itemprop="url">
                  linux shell系列-- 如何在系统中保证只有一个实例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-01T13:06:25+08:00">
                2016-11-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/01/2016-11-1-keep-one-instance-in-a-machine/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/11/01/2016-11-1-keep-one-instance-in-a-machine/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">如何在系统中保证只有一个实例 </a></p>
<p><a href="#B">写 pid 方式 </a></p>
<p><a href="#C">文件锁的方式</a></p>
<p><a href="#D">独占端口的方式</a></p>
<p><a href="#E"> dbus API</a></p>
<p><a href="#F">写成service并交由第三方托管</a></p>
<p><a name="A"></a></p>
<h2 id="如何在系统中保证只有一个实例"><a href="#如何在系统中保证只有一个实例" class="headerlink" title="如何在系统中保证只有一个实例"></a>如何在系统中保证只有一个实例</h2><p>从这发现的这个问题，<a href="https://www.v2ex.com/t/316723#reply21" target="_blank" rel="noopener">如何确保系统中某个程序只存在一个实例</a></p>
<p>从评论区中汇总几种可行的方案并实验，记录如下，。</p>
<p><a name="B"></a></p>
<h2 id="写-pid-方式"><a href="#写-pid-方式" class="headerlink" title="写 pid 方式"></a>写 pid 方式</h2><p>这种方式应该是最直观，最容易想到的，类似于算法中的暴力破解法。原理就是在程序执行之前将PID写入某个约定好的文件，每次程序启动前通过检测该PID对应的程序是否存在来判断。它的伪代码如下：</p>
<blockquote>
<p>Invariant:<br>    File xxxxx will exist if and only if the program is running, and the<br>    contents of the file will contain the PID of that program.</p>
</blockquote>
<pre><code>On startup:
    If file xxxxx exists:
        If there is a process with the PID contained in the file:
            Assume there is some instance of the program, and exit
        Else:
            Assume that the program terminated abnormally, and
            overwrite file xxxx with the PID of this program
    Else:
        Create file xxxx, and save the current PID to that file.

On termination (typically registered via atexit):
    Delete file xxxxx
</code></pre><p>这种方式还要注意假如两个程序同时读取文件的时候这种情况，可以再加一个文件锁（其实就是下面的方式了）。</p>
<p><a name="C"></a></p>
<h2 id="文件锁的方式"><a href="#文件锁的方式" class="headerlink" title="文件锁的方式"></a>文件锁的方式</h2><p>对文件锁的概念其实一直比较陌生，但其实与我们还是挺接近的。我们数据库中经常出现锁表或者锁记录的情况，就是利用文件锁实现的。关于文件锁的理论知识可以参考如下一篇文章：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-filelock/" target="_blank" rel="noopener">Linux 2.6 中的文件锁</a></p>
<p>一个简单的demo如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> fcntl</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line">FILE = <span class="string">"flag-file.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(FILE):</span><br><span class="line">    file = open(FILE,<span class="string">"w"</span>)</span><br><span class="line">    file.write(<span class="string">""</span>+os.getpid())</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line">file = open(FILE,<span class="string">"r+"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fcntl.flock(file.fileno(),fcntl.LOCK_EX | fcntl.LOCK_NB)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"acquire lock, i am running"</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)    </span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"another programme is running"</span></span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/2016-11-01fcntl.png" alt="demo"></p>
<p>使用这种方式有个地方要注意：你不知道什么时候别人可能把你作为flag的文件给删除了。当然可以通过逻辑判断的方式来解决，但当程序比较复杂的时候可能还会出现意料外的问题。所以我们可以用端口独占的方式来避免这种情况。</p>
<p><a name="D"></a></p>
<h2 id="独占端口的方式"><a href="#独占端口的方式" class="headerlink" title="独占端口的方式"></a>独占端口的方式</h2><p>同上，通过独占端口的方式来达到互斥的效果，demo如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line">PORT = <span class="number">888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_port</span><span class="params">(ip,port)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.bind((ip,int(port)))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"port is open,i'm running"</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"another programme is running"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    check_port(<span class="string">"127.0.0.1"</span>,PORT)</span><br></pre></td></tr></table></figure>
<p><a name="E"></a></p>
<h2 id="dbus-API"><a href="#dbus-API" class="headerlink" title="dbus API"></a>dbus API</h2><p>首先简单介绍下什么是 dbus,直接引用wiki：</p>
<blockquote>
<p>D-Bus是一个进程间通信及远程过程调用机制，可以让多个不同的计算机程序（即进程）在同一台电脑上同时进行通信[4]。D-Bus作为freedesktop.org项目的一部分，其设计目的是使Linux桌面环境（如GNOME与KDE等）提供的服务标准化。</p>
</blockquote>
<p> dbus 的Python库主要有几下几个</p>
<p> 1,GDbus and QtDbus are wrappers over the C/C++ APIs of GLib and Qt</p>
<p> 2,pydbus is a modern, pythonic API with the goal of being as invisible a layer between the exported API and its user as possible</p>
<p> 3,dbus-python is a legacy API, built with a deprecated dbus-glib library, and involving a lot of type-guessing (despite “explicit is better than implicit” and “resist the temptation to guess”).</p>
<p> 4,txdbus is a native Python implementation of the D-Bus protocol for the Twisted networking framework.</p>
<p>demo代码如下，因为对dbus这一块不熟，好像有个地方参数不对，后续再调吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> dbus</span><br><span class="line"><span class="keyword">import</span> dbus.service</span><br><span class="line"><span class="keyword">import</span> dbus.mainloop.glib</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_dbus</span><span class="params">(bus_name)</span>:</span></span><br><span class="line">    dbus.mainloop.glib.DBusGMainLoop(set_as_default = <span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#bus = dbus.SessionBus()</span></span><br><span class="line">    <span class="comment"># s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        my_bus_name = dbus.service.BusName(bus_name,</span><br><span class="line">                    bus, allow_replacement = <span class="keyword">False</span>, replace_existing = <span class="keyword">True</span>, do_not_queue = <span class="keyword">True</span>)</span><br><span class="line">        <span class="comment">#s.bind((ip,int(port)))</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"i'm running"</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"another programme is running"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    check_dbus(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>
<p><a name="F"></a></p>
<h2 id="写成service并交由第三方托管"><a href="#写成service并交由第三方托管" class="headerlink" title="写成service并交由第三方托管"></a>写成service并交由第三方托管</h2><p>这个就没什么好说的了，将Python文件打包并执行，由supevisor等第三方工具来管理。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.v2ex.com/t/316723#reply21" target="_blank" rel="noopener">v2ex</a></p>
<p><a href="http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux" target="_blank" rel="noopener">stackoverflow-Preventing multiple process instances on Linux</a></p>
<p><a href="http://blog.jobbole.com/102538/" target="_blank" rel="noopener">Linux 编程中的文件锁之 flock</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-filelock/" target="_blank" rel="noopener">Linux 2.6 中的文件锁</a></p>
<p><a href="https://wiki.python.org/moin/DbusExamples" target="_blank" rel="noopener">Python wiki</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/10/31/openstack-rally/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/31/openstack-rally/" itemprop="url">
                  openstack系列-- benchmarking工具rally
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-31T17:06:25+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/31/openstack-rally/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/10/31/openstack-rally/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">ralley是什么 </a></p>
<p><a href="#B">rally 安装以及快速引导 </a></p>
<p><a href="#C">rally 任务启动配置文件</a></p>
<p><a href="#D">rally 插件</a></p>
<p><a name="A"></a></p>
<h2 id="ralley是什么"><a href="#ralley是什么" class="headerlink" title="ralley是什么"></a>ralley是什么</h2><p>一句话概括，rally是一个测试openstack 性能的工具。它的存在主要回答这样一个问题：How does OpenStack work at scale? 意译一下就是：openstack 在负载比较大的规模下运转情况怎么样？<br>rally以一种插件式的形式工作，对openstack是无侵入的。通常会作为CI的一种功能集成到CI中去。</p>
<p>tips:<br>随着rally项目的不断发展，rally又衍生出了其他的一些功能，比如与tempest结合进行openstack的功能测试等。如下图</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161031Rally-Actions.png" alt="rally action"></p>
<p>deploy(部署)功能并非是另一种部署方式，只是与devstack等部署方式以插件形式结合来简化工作而已。</p>
<p><a name="B"></a></p>
<h2 id="rally-安装以及快速引导"><a href="#rally-安装以及快速引导" class="headerlink" title="rally 安装以及快速引导"></a>rally 安装以及快速引导</h2><p>rally 安装比较简单，还可以跟Devstack 部署时一块安装，以及docker 安装<a href="https://rally.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">check this!</a></p>
<p>安装完成之后我们就可以进行性能测试了，大致顺序如下：</p>
<ul>
<li><p>创建一个openstack 的rally测试环境：如果是有现成的openrc文件，那么直接source 一下，然后执行：  rally deployment create –fromenv –name=existing 就创建完成了。也可以将openrc文件中的内容写入一个json文件，假设取名为existing.json,执行如下命令： rally deployment create –file=existing.json –name=existing 。 执行rally deployment list 即可查看我们创建的deployment 以及哪一个正在被激活（正在使用）。<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161031rally2.png" alt="rally deployment"><br>通过 rally deployment check 可查看检测到的openstack服务：<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161031rally1.png" alt="rally check"></p>
</li>
<li><p>创建完一个deployment之后我们就可以进行测试了，我们需要指定一个json或yaml文件 来说明测试的内容， 在rally安装目录samples/tasks/scenarios 中有很多示例文件，比如samples/tasks/scenarios/nova 目录下就有nova对应的情景测试文件，例如boot-and-delete.json，就是启动虚拟机再删除操作，内容如下：</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"NovaServers.boot_and_delete_server"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"args"</span>: &#123;</span><br><span class="line">                <span class="attr">"flavor"</span>: &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"m1.tiny"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"image"</span>: &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"^cirros.*uec$"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"force_delete"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"runner"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"constant"</span>,</span><br><span class="line">                <span class="attr">"times"</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">"concurrency"</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"context"</span>: &#123;</span><br><span class="line">                <span class="attr">"users"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tenants"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">"users_per_tenant"</span>: <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用此文件启动任务： rally task start samples/tasks/scenarios/nova/boot-and-delete.json<br>还可以利用rally查看images ，flavors列表等。</p>
<ul>
<li><p>rally提供了多种方式进行结果的查看，最直观的就是以html形式在浏览器中展现（需翻墙）：<br>rally task report –out=report1.html –open </p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161031rally3.png" alt="rally pic"></p>
</li>
</ul>
<p>tips:执行任务时指定的json 文件格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"&lt;ScenarioName1&gt;"</span>: [&lt;benchmark_config&gt;, &lt;benchmark_config2&gt;, ...]</span><br><span class="line">    <span class="string">"&lt;ScenarioName2&gt;"</span>: [&lt;benchmark_config&gt;, ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， &lt;benchmark_config&gt; 格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "args": &#123; &lt;scenario-specific arguments&gt; &#125;,</span><br><span class="line">    "runner": &#123; &lt;type of the runner and its specific parameters&gt; &#125;,</span><br><span class="line">    "context": &#123; &lt;contexts needed for this scenario&gt; &#125;,</span><br><span class="line">    "sla": </span><br><span class="line">    &#123; &lt;different SLA configs&gt; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="C"></a></p>
<h2 id="rally-任务启动配置文件"><a href="#rally-任务启动配置文件" class="headerlink" title="rally 任务启动配置文件"></a>rally 任务启动配置文件</h2><p>rally任务启动配置文件就是上文中提到过的json/yaml文件，其实可以通过此配置文件实现很多功能，比如：多任务配置，设置SLA(Service-Level Agreement,就是一个成功与否的基准，例如：max_seconds_per_iteration”: 10)，利用jinja模板传参数进来，或利用jinja模板进行简单的逻辑控制等，<a href="http://rally.readthedocs.io/en/latest/tutorial/step_5_task_templates.html" target="_blank" rel="noopener">check this</a>,不再赘述。 </p>
<p><a name="D"></a></p>
<h2 id="rally-插件"><a href="#rally-插件" class="headerlink" title="rally 插件"></a>rally 插件</h2><p>rally插件就是我们在json文件中配置的ScenarioName，通过这些插件的组合可以完成我们自己定义的要求。几个命令如下：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161031rallyplugin.png" alt="rally plugin"></p>
<p>关于rally与tempest的结合使用还不是很成熟，感兴趣的可以去试下，<a href="http://rally.readthedocs.io/en/latest/tutorial/step_10_verifying_cloud_via_tempest.html" target="_blank" rel="noopener">check this!</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wiki.openstack.org/wiki/Rally" target="_blank" rel="noopener">openstack rally wiki</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/cloud/library/1604-rally-openstack-tempest/" target="_blank" rel="noopener">SDN使用 Rally 来实现 Openstack Tempest 测试</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/10/24/openstack-keystone-config/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/openstack-keystone-config/" itemprop="url">
                  openstack系列 --关于keystone配置详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-24T15:01:55+08:00">
                2016-10-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/24/openstack-keystone-config/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/10/24/openstack-keystone-config/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">keystone 配置文件综述 </a></p>
<p><a href="#B">keystone 配置文件详解</a></p>
<p><a name="A"></a></p>
<h2 id="keystone-配置文件综述"><a href="#keystone-配置文件综述" class="headerlink" title="keystone 配置文件综述"></a>keystone 配置文件综述</h2><p>关于keystone的概述以及整体架构我们已经在之前的<a href="http://zhangchenchen.github.io/2016/09/16/openstack-keystone/">一篇文章</a>中做过介绍，不再赘述。这里具体介绍下keystone的配置方面的知识。</p>
<p>首先，keystone的配置文件主要有两个，一个是通常位于/etc/keystone/或/etc/目录下的keystone.conf，另一个是位于keystone安装根目录下的keystone-paste.ini。其中，后者其实就是paste deploy 文件，我们这里不需要关注，主要讨论keystone.conf文件。</p>
<p>tips:keystone默认端口是35357，因此我们最好将35357端口从临时端口范围中删除，以免该端口被用作临时端口。<br>命令如下： </p>
<blockquote>
<p>sysctl -w ‘net.ipv4.ip_local_reserved_ports=35357’</p>
</blockquote>
<p>如果是想重启后仍然有效，在/etc/sysctl.conf 或/etc/sysctl.d/keystone.conf文件后追加： net.ipv4.ip_local_reserved_ports = 35357 </p>
<p><a name="B"></a></p>
<h2 id="keystone-配置文件详解"><a href="#keystone-配置文件详解" class="headerlink" title="keystone 配置文件详解"></a>keystone 配置文件详解</h2><p>keystone.conf文件中所有的配置项如下：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161024-keystone-config.png" alt="keystone-config"></p>
<p>接下来我们从其中挑选几个值得注意的配置项详细说明下：</p>
<ol>
<li>关于TOKEN</li>
</ol>
<p>对于token的持久化有两种形式：一种是以key/value对的形式存储，另一种是存储在SQL数据库中。<br>需要在[token] 配置项中的driver选项进行具体配置。</p>
<p>token provider 大致有以下四种形式：</p>
<ul>
<li>UUID:长度固定为 32 Byte 的随机字符串,UUID token 简单美观,验证流程如下：</li>
</ul>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161024-uuid.png" alt="uuid"><br>由于每当 OpenStack API 收到用户请求，都需要向 Keystone 验证该 token 是否有效。随着集群规模的扩大，Keystone 需处理大量验证 token 的请求，在高并发下容易出现性能问题。为了杜绝keystone成为瓶颈，引出了下面的几种。</p>
<ul>
<li>PKI:验证流程如下：<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161024-pki.png" alt="pki"><br>可以看出，PKI token携带更多用户信息的同时还附上了数字签名，以支持本地认证，从而避免了步骤 4。因为 PKI token 携带了更多的信息，这些信息就包括 service catalog，随着 OpenStack 的 Region 数增多，service catalog 携带的 endpoint 数量越多，PKI token 也相应增大，很容易超出 HTTP Server 允许的最大 HTTP Header(默认为 8 KB)，导致 HTTP 请求失败。</li>
<li>PKIZ:顾名思义，就是对PKI token进行压缩，但压缩效果有限，无法良好的处理 token size 过大问题。原理同上，无须赘述。</li>
<li>FERNET:前三种 token 都会持久性存于数据库，与日俱增积累的大量 token 引起数据库性能下降，所以用户需经常清理数据库的 token（ 命令为：keystone-manage token_flush）。为了避免该问题，社区提出了 Fernet token，它携带了少量的用户信息，大小约为 255 Byte，采用了对称加密，无需存于数据库中。</li>
</ul>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161024-fernet.png" alt="fernet"></p>
<ul>
<li>几种token provider比较如下：</li>
</ul>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161024-token%20compare.png" alt="token比较"></p>
<ol start="2">
<li>Caching Layer</li>
</ol>
<p>启动keystone的的cache功能，首先要在[cache]配置项，设置为enabled,指定backend等等。然后再在其他具体配置项进行设置。支持cache的地方有以下几个地方：</p>
<ul>
<li>token</li>
<li>resource</li>
<li>role<br>具体配置根据backend的不同也不尽相同。</li>
</ul>
<ol start="3">
<li>Service Catalog<br>keystone 提供了两种配置选项。<ul>
<li>SQL-based Service Catalog：配置选项如下：</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[catalog]</span><br><span class="line">driver = sql</span><br></pre></td></tr></table></figure>
<p>可以通过查阅以下命令进行相关操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openstack --<span class="built_in">help</span></span><br><span class="line">openstack <span class="built_in">help</span> service create</span><br><span class="line">openstack <span class="built_in">help</span> endpoint create</span><br></pre></td></tr></table></figure>
<ul>
<li><p>File-based Service Catalog (templated.Catalog)：就是基于一个配置模板文件，配置选项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[catalog]</span><br><span class="line">driver = templated</span><br><span class="line">template_file = /opt/stack/keystone/etc/default_catalog.templates</span><br></pre></td></tr></table></figure>
<p>模板文件示例：<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161024-template.png" alt="template"></p>
</li>
</ul>
<ol start="4">
<li>其他</li>
</ol>
<p>其实，除了sql数据库，我们也可以把数据存在文件中，以 LDAP形式，不过用的不多，不再赘述。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://docs.openstack.org/developer/keystone/configuration.html" target="_blank" rel="noopener">openstack doc </a></p>
<p><a href="http://www.openstack.cn/?p=5120" target="_blank" rel="noopener">理解 Keystone 的四种 Token</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/10/17/github-tips/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/17/github-tips/" itemprop="url">
                  git系列--关于github 的碎碎念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-17T22:01:21+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/17/github-tips/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/10/17/github-tips/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">github 快捷键 </a></p>
<p><a href="#B">github trending &amp;&amp; github subscribe </a></p>
<p><a href="#C">为开源项目贡献代码</a></p>
<p><a href="#D">git 常用命令</a></p>
<p><a name="A"></a></p>
<h2 id="github-快捷键"><a href="#github-快捷键" class="headerlink" title="github 快捷键"></a>github 快捷键</h2><p>逛v2ex的时候逛到了这个帖子，<a href="https://www.v2ex.com/t/313267#reply54" target="_blank" rel="noopener">录了几个有关 Github 的视频，我觉得你也应该知道这些</a>,很有意思,把视频看了一遍，都不是很长，强烈推荐。顺手记录下这些信息。<br>首先是github的一些快捷键：</p>
<ul>
<li><p>项目中搜索含有某个关键字的文件：在github 项目的code目录按下 “t”,即可进入搜索页面，如下图：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161017github-search.jpg" alt="search"></p>
</li>
<li><p>列出github的快捷键：在项目目录按下 “？” 即可出现：</p>
</li>
</ul>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20161017shortcut.jpg" alt="github shortcut"></p>
<ul>
<li>进入 issue页面：按下“g” 与 “i”键，就是goto issue 的缩写</li>
<li>进入code页面：按下“g”与“c”键，goto code</li>
</ul>
<p>其他的按下“？”自己探索吧。</p>
<p><a name="B"></a></p>
<h2 id="github-trending-amp-amp-github-subscribe"><a href="#github-trending-amp-amp-github-subscribe" class="headerlink" title="github trending &amp;&amp; github subscribe"></a>github trending &amp;&amp; github subscribe</h2><ul>
<li>github trending:进入这个页面<a href="github.com/trending">github trending</a>就可以看到最近按照stars数排序靠前的比较优秀的项目，可以按照语言分类。</li>
<li>github subscribe:进入这个页面<a href="https://github.com/explore/subscribe" target="_blank" rel="noopener">github subscribe</a>,我们可以订阅我们关注的大牛，他们的动态会按周/月发送到你的邮箱。</li>
</ul>
<p><a name="C"></a></p>
<h2 id="为开源项目贡献代码"><a href="#为开源项目贡献代码" class="headerlink" title="为开源项目贡献代码"></a>为开源项目贡献代码</h2><p>关于这个，强烈推荐看下视频吧，直观易懂。这里简短记录下过程：</p>
<ul>
<li>fork and clone </li>
<li>github remote -add upstream <a href="mailto:ssh@xxxxxxxx.git" target="_blank" rel="noopener">ssh@xxxxxxxx.git</a> :标示我们fork的上级，master分支要与upstream分支保持一致</li>
<li>github checkout -b feature/bug-fixed : 创建并切换分支，在此分支上编码。</li>
<li>git add &amp;&amp; commit </li>
<li>git checkout master &amp;&amp; git pull upstream master：在push之前我们先要保证master与upstream一致。</li>
<li>git checkout feature/bug-fixed &amp;&amp; git rebase master：将在bug-fixed上的commit log 打到master分支的最上面。</li>
<li>git push origin featue/bug-fixed</li>
<li>git pull request: 现在可以向开源作者pull request了</li>
</ul>
<p><a name="D"></a></p>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><ul>
<li><p>切换分支后，清理本地目录：git reset –hard HEAD &amp;&amp; git clean -i </p>
</li>
<li><p>不详细写了，以后用得着直接去这个页面找吧：<br><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a></p>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.v2ex.com/t/313267#reply54" target="_blank" rel="noopener">v2ex</a></p>
<p><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/29/ceph-intro/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/ceph-intro/" itemprop="url">
                  ceph系列--ceph存储介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-29T14:24:25+08:00">
                2016-09-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/29/ceph-intro/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/29/ceph-intro/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">关于分布式存储</a></p>
<p><a href="#B">ceph 是什么 </a></p>
<p><a href="#B">ceph 架构</a></p>
<p><a href="#C">what makes ceph unique</a></p>
<p><a name="A"></a></p>
<h2 id="关于分布式存储"><a href="#关于分布式存储" class="headerlink" title="关于分布式存储"></a>关于分布式存储</h2><p>在了解ceph之前，我们最好还是先了解一下分布式存储的一些概念。分布式存储是随着存储容量的需求变大而出现的概念。由于存储需求变大，出现了两种解决方案，一种是scale up,采用容量更大，价格更昂贵的存储机器。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/scale-up.png" alt="scale-up"> </p>
<p>另一种是scale out,利用众多的普通存储机器（PC机）横向扩展成一个大的存储集群。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929scale-out.png" alt="scale-out"></p>
<p>第二种就是分布式存储的概念了。相对采用昂贵的专用商业存储设备来说，这种存储的性价比更高，但也因此引出了分布式存储几个比较棘手的问题，比如数据如何组织存储，如何保证高可用性，如何保证冗余数据的一致性，是否支持分布式事务，如何避免单点失败等等，这些概念可以参考这两篇文章，<a href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/" target="_blank" rel="noopener">分布式存储系统 知识体系</a>,<a href="http://webdam.inria.fr/Jorge/html/wdmch15.html" target="_blank" rel="noopener">An Introduction to Distributed Systems</a>。</p>
<p><a name="B"></a></p>
<h2 id="ceph-是什么"><a href="#ceph-是什么" class="headerlink" title="ceph 是什么"></a>ceph 是什么</h2><p>以下篇目是基于这场presentation，<a href="https://www.youtube.com/watch?v=7I9uxoEhUdY" target="_blank" rel="noopener">Ceph Intro &amp; Architectural Overview</a>.</p>
<p>我们首先看一下ceph 的设计哲学：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-ceph-design.png" alt="ceph design"></p>
<p>由此我们也可以看出ceph的一些特点：开源，社区驱动，可扩展，无单点故障，软件层面，自我管理。</p>
<p>那具体提供什么服务呢？看下图</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-ceph-service.png" alt="ceph service"></p>
<p>对应过来就是对象存储，块存储，文件系统存储。</p>
<p><a name="C"></a></p>
<h2 id="ceph-架构"><a href="#ceph-架构" class="headerlink" title="ceph 架构"></a>ceph 架构</h2><p>再从技术层面看下ceph架构</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/2016-09-29ceph-architect.png" alt="ceph-architect"></p>
<p>我们从底往上一层层的介绍，首先是RADOS,我们从上图的介绍中也可以看出，RADOS是一系列的节点，这些节点上跑着两种程序，跑着OSD程序的我们称为OSD节点（storage node），跑着MON程序的我们称为MON节点（monitor node）。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/2016-09-29-rados-1.png" alt="rados-1"></p>
<p>我们再详细看下OSD节点。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-rados-osd.png" alt="rados-osd"></p>
<p>每个OSD节点内，有多个磁盘disk,这些磁盘上是对应的文件系统（官网推荐 xfs），在往上就是我们的逻辑存储单元OSD，每个磁盘对应一个OSD。我们的数据就是存储在OSD里。<br>OSD与MON节点各自功能如下：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-OSD-MON.png" alt="OSD VS MON"></p>
<p>可以看出MON节点只负责集群状态的维护，具体存储交给OSD处理。</p>
<p>再看下LIBRADOS的作用。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929ceph-librados-service.png" alt="ceph-librados-service"></p>
<p>简而言之，就是为Application的调用提供了多种语言版本的接口。通信机制为SOCKET。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-librados.png" alt="librados"></p>
<p>再往上是RADOSGW.</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-radosgw-1.png" alt="RADOSGW-1"></p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-radosgw-2.png" alt="RADOSGW-1"></p>
<p>简而言之，就是在LIBRADOS提供的API的基础上进行封装对外提供对象存储的REST服务。</p>
<p>与之并列的是RBD，也就是ceph提供的块存储服务。我们最常用的就是attach到某台虚拟机上（如下图），Ross Turk还提到了另外两种用法，感兴趣可以去看一下。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929ceph-rbd-1.png" alt="ceph-rbd"></p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-ceph-rbd-2.png" alt="ceph-rbd"></p>
<p>关于ceph提供的文件系统因为用的不多，不再详述。</p>
<p><a name="D"></a></p>
<h2 id="what-makes-ceph-unique"><a href="#what-makes-ceph-unique" class="headerlink" title="what makes ceph unique"></a>what makes ceph unique</h2><p>第一个就是crush算法，一种计算寻址而非查找寻址的方法。</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-crush-3.png" alt="crush-3"></p>
<p> 图中的placement group 有很重要的作用，有了它，我们底层添加节点或节点崩溃，ceph都会自动更新，而对用户是透明的。<br><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-crush-1.png" alt="crush-1"></p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160929-crush-2.png" alt="crush-2"></p>
<p>其次是 rbdlayering ,参考这里<a href="http://docs.ceph.com/docs/master/dev/rbd-layering/" target="_blank" rel="noopener">RBD LAYERING</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.youtube.com/watch?v=7I9uxoEhUdY" target="_blank" rel="noopener">Ceph Intro &amp; Architectural Overview</a></p>
<p><a href="http://www.slideshare.net/buildacloud/ceph-intro-and-architectural-overview-by-ross-turk" target="_blank" rel="noopener">Ceph Intro and Architectural Overview by Ross Turk</a></p>
<p><a href="http://www.cnblogs.com/sammyliu/p/4836014.html" target="_blank" rel="noopener">理解 OpenStack + Ceph （2）：Ceph 的物理和逻辑结构 [Ceph Architecture]</a></p>
<p><a href="http://docs.ceph.com/docs/master/" target="_blank" rel="noopener">ceph doc</a><br><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/26/python-yield-and coroutine/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/26/python-yield-and coroutine/" itemprop="url">
                  python系列--Python中的生成器以及协程的相关知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-26T14:24:25+08:00">
                2016-09-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/26/python-yield-and coroutine/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/26/python-yield-and coroutine/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">迭代器与生成器 </a></p>
<p><a href="#B">yield, send 关键字解析 </a></p>
<p><a href="#C">协程的一些知识</a></p>
<p><a name="A"></a></p>
<h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><p>在说生成器之前我们得先讨论一下迭代器的概念。</p>
<p>我们知道，对于一个可迭代的对象，我们可以通过 for <em> in </em> 的语句来进行迭代输出。这个可迭代的对象可以是一个list，string，文件等。其实我们深入这个可迭代的对象会发现，这些可迭代对象都实现了两个函数：<strong>iter</strong>() 和 next()。在我们调用list等这些可迭代对象的时候，需要把整个list数据全部读到内存里。这样就存在一个问题：list数据量小还可以，一旦变得特别大，内存就有可能被占满而导致运行缓慢甚至崩溃。这个时候我们想到，能不能只把我们需要的那个数据读入内存，调用next()的时候再把下一个数据读入内存呢。这就是生成器了。</p>
<p>一般来说，含有 yield 语句的函数就可叫做生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">ge = g()</span><br><span class="line">type(ge) <span class="comment">#ge 的类型为 'generator'</span></span><br><span class="line">dir(ge) <span class="comment">#列出ge包含的函数我们发现有__iter__() 和 next()</span></span><br><span class="line">ge.next()</span><br><span class="line">ge.next()</span><br><span class="line">ge.next()</span><br></pre></td></tr></table></figure>
<p>生成器也是一种迭代器，但我们只可以读取它一次，因为它并非把所有数据都存入内存中，而是实时地生成数据。上述例子当我们再次读取ge.next()后就会报错。</p>
<p>此处再略提一下生成器推导式：<br>我们知道Python中有各种集合的推导式，如下：</p>
<ul>
<li>列表推导式：my_list = [ f(x) for x in sequence if cond(x) ]</li>
<li>字典推导式：my_dict = { k(x): v(x) for x in sequence if cond(x) }</li>
<li>集合推导式：my_set = { f(x) for x in sequence if cond(x) }</li>
</ul>
<p>相应的，我们也可以用推导式来生成生成器，跟列表推导式类似，只需要将[]改为()：<br>my_generator = ( f(x) for x in sequence if cond(x) )</p>
<p><a name="B"></a></p>
<h2 id="yield-send-关键字解析"><a href="#yield-send-关键字解析" class="headerlink" title="yield, send 关键字解析"></a>yield, send 关键字解析</h2><p>由上文可以看到，yield关键字是理解生成器的关键。那么yield什么意思呢？我们来详细解释一下。<br>yield 关键字有点类似我们平常写程序用到的return。但是程序运行到return的时候就会返回，运行完毕。而运行到yield的时候也会返回，但会保存上下文之后再返回，等到下次再次唤醒该程序的时候恢复上下文，继续从此运行，直到碰到下一次yield。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator :</span><br><span class="line">   print(i) <span class="comment">#输出0,1,4</span></span><br></pre></td></tr></table></figure>
<p>首先我们创建了一个生成器mygenerator，注意，此时程序并不执行，只是创建了一个生成器。接着是一个for循环,fou循环其实就是执行了一个next()函数，此时进入生成器获取第一个i就是0乘以0，也就是0。返回并输出。再次循环，进入生成器，以此类推。这个例子可能不是特别直接，只是说明一下运行的逻辑顺序，下文中我们有一个更为直接的实例。</p>
<p>我们先看一下send()函数再将两个函数放在一个例子中说明一下。</p>
<p>在调用生成器时，除了next()方法，我们还可以用send()方法唤醒生成器，而且send(args),在唤醒生成器的同时会把参数 args传给指定的数据。如下例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span>     <span class="comment">#定义一个生成器函数</span></span><br><span class="line">     <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">         val = <span class="keyword">yield</span> <span class="comment"># val接受send()传过来的的参数并赋值</span></span><br><span class="line">         <span class="keyword">yield</span> val*<span class="number">10</span> </span><br><span class="line"></span><br><span class="line">g = f() <span class="comment">#新建一个生成器</span></span><br><span class="line">g.next() <span class="comment">#触发生成器，生成器执行到val=yield ，保存上下文退出，等待传值</span></span><br><span class="line">g.send(<span class="number">1</span>) <span class="comment"># 触发生成器，生成器继续执行，赋值val = 1，执行到yield val*10，保存上下文，,返回10，退出。</span></span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">#同上</span></span><br><span class="line">g.send(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">g.next()</span><br><span class="line">g.send(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，我们在用send()之前必须保证生成器已经执行到yield,也就是说生成器已经被触发过一次，我们可以用send(none)来实现。其实，next()跟send(none)效果是一样的。</p>
<p>接下来我们看一个比较复杂的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2016-09-22 16:40:36</span></span><br><span class="line"><span class="comment"># @Author  : Zhang Chen (pekingzcc@gmail.com)</span></span><br><span class="line"><span class="comment"># @Link    : zhangchenchen.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Into genaration :counting down from"</span>, n</span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Genaration: ###loops from here###"</span></span><br><span class="line">        newvalue = (<span class="keyword">yield</span> n)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Gerenation: newvalue is"</span>,newvalue</span><br><span class="line">        <span class="comment"># If a new value got sent in, reset n with it</span></span><br><span class="line">        <span class="keyword">if</span> newvalue <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            n = newvalue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    c = countdown(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Main function begin from here "</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> c:</span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Main function: x is"</span>, x</span><br><span class="line">         <span class="keyword">if</span> x == <span class="number">5</span>:</span><br><span class="line">            c.send(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子看明白了，yield与send的用法就理解的差不多了。<br>我们首先看一下执行结果：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160926python-yield.png" alt="python-yield"></p>
<p>接下来分析一下：我们从main 函数开始，先创建了一个生成器（此时并未执行），接着输出main函数开始的语句。接着进入for循环，注意，遇到for循环就相当于执行了一次next(),所以进入生成器输出“Into genaration :counting down from 5”，继续运行，进入生成器的for循环，输出“Genaration: ###loops from here###”，继续往下，碰到yield n ，保存上下文，退出并返回n(此时是5)到main函数，主函数输出“Main function: x is 5”，进入条件语句，c.send(5)触发生成器，再次进入生成器，赋值newvalue为3，接着输出“Gerenation: newvalue is 3” ，赋值n = newvalue =3 ,继续循环输出“Genaration: ###loops from here###”，碰到yield n ,返回main函数，注意，此时main函数又进入到for循环，所以再次进入生成器，但是没有send()数据传过来，也可以理解为send(none),所以输出“Gerenation: newvalue is none”,接着执行n-1 ,n变为2。继续循环，输出“Genaration: ###loops from here###”。。。。。</p>
<p><a name="C"></a></p>
<h2 id="协程的一些知识"><a href="#协程的一些知识" class="headerlink" title="协程的一些知识"></a>协程的一些知识</h2><p>在了解协程之前，我们需要先从进程，线程说起。我们知道，进程的出现是为了并发，在一台机器上同时运行多个程序（当然，内部实现可能是多CPU并行，也有可能是单CPU时间分片，但在外部看来就是多个程序一起运行），进程的切换需要陷入内核，由OS来进行切换。一切换进程得反复进入内核，置换掉一大堆状态，这样，进程数一高，就会吃掉很多的系统资源。为了解决这个问题，就出现了线程的概念。</p>
<p>一个进程里可以有多个线程，这样就能处理多个逻辑，当某个线程阻塞的时候，可以切换线程到另一个线程。因为线程是共享附属进程的资源的，它们件的切换相对要比进程间的切换消耗的资源要少很多。但之后，问题又来了，操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还需要做这些数据的恢复操作，所以线程多了之后，它们之间的切换也非常耗性能。</p>
<p>协程的概念就来了，既然线程切换费资源，那我们干脆自己做逻辑流的切换，不用交给OS处理。注意，这里经常提到的是切换，具体到应用场景就是IO密集型场景。在cpu密集型的场景中协程的意义就没有那么大了。在IO处理时，我们有同步，异步两种处理方式，关于IO模型，可以<a href="http://www.jianshu.com/p/55eb83d60ab1" target="_blank" rel="noopener">check this</a> 。在异步处理IO时，我们需要写回调函数来实现异步，这种写法是比较反人类的，可读性比较差。协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。协程的切换很轻，消耗资源少。协程通过这种对异步IO的封装既保留了性能也保证了代码的 容易编写和可读性。</p>
<p>其实协程不是一个新生的事物，它在很早之前就出现了，只不过最近因为在一些动态语言的世界里大放异彩。对其历史感兴趣的<a href="http://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">check this</a>。</p>
<p>再简单说一下Python中的协程，其实Python中的协程跟yield关键字是分不开的。只要含有yield的函数都可以认为是一个协程，利用协程实现的生产者消费者如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""返回0到9之间的3个随机数，模拟异步操作"""</span></span><br><span class="line">    <span class="keyword">return</span> random.sample(range(<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示每次传入的整数列表的动态平均值"""</span></span><br><span class="line">    running_sum = <span class="number">0</span></span><br><span class="line">    data_items_seen = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'Waiting to consume'</span>)</span><br><span class="line">        data = <span class="keyword">yield</span></span><br><span class="line">        data_items_seen += len(data)</span><br><span class="line">        running_sum += sum(data)</span><br><span class="line">        print(<span class="string">'Consumed, the running average is &#123;&#125;'</span>.format(running_sum / float(data_items_seen)))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(consumer)</span>:</span></span><br><span class="line">    <span class="string">"""产生序列集合，传递给消费函数（consumer）"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = get_data()</span><br><span class="line">        print(<span class="string">'Produced &#123;&#125;'</span>.format(data))</span><br><span class="line">        consumer.send(data)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    consumer = consume()</span><br><span class="line">    consumer.send(<span class="keyword">None</span>) </span><br><span class="line">    producer = produce(consumer)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">'Producing...'</span>)</span><br><span class="line">        next(producer)</span><br></pre></td></tr></table></figure>
<p>利用协程的Python库比较常见的是Greenlet库，它是以C扩展模块形式接入Python的轻量级协程，将一些原本同步运行的网络库以mockey_patch的方式进行了重写。Greenlets全部运行在主程序操作系统进程的内部，它们被协作式地调度。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf" target="_blank" rel="noopener">A Curious Course on Coroutines and Concurrency</a></p>
<p><a href="https://www.oschina.net/translate/improve-your-python-yield-and-generators-explained" target="_blank" rel="noopener">提高你的Python: 解释‘yield’和‘Generators（生成器）</a></p>
<p><a href="http://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html" target="_blank" rel="noopener">(译)Python关键字yield的解释(stackoverflow)</a></p>
<p><a href="https://segmentfault.com/a/1190000001813992" target="_blank" rel="noopener">Python 中的进程、线程、协程、同步、异步、回调</a></p>
<p><a href="http://codingpy.com/article/what-is-generator-comprehension/" target="_blank" rel="noopener">什么是Python中的生成器推导式？</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/start-learning-python/215.html" target="_blank" rel="noopener">生成器</a></p>
<p><a href="http://manjusaka.itscoder.com/2016/09/11/something-about-yield-in-python/" target="_blank" rel="noopener">聊聊 Python 中生成器和协程那点事儿</a></p>
<p><a href="http://www.bogotobogo.com/python/python_function_with_generator_send_method_yield_keyword_iterator_next.php" target="_blank" rel="noopener">GENERATOR.SEND() WITH YIELD</a></p>
<p><a href="http://blog.kazaff.me/2016/05/29/%E4%BA%86%E8%A7%A3%E5%8D%8F%E7%A8%8B(coroutine" target="_blank" rel="noopener">了解协程（Coroutine）</a>/)</p>
<p><a href="https://www.zhihu.com/question/20511233" target="_blank" rel="noopener">协程的好处是什么？</a></p>
<p><a href="https://www.zhihu.com/question/32218874/answer/55469714" target="_blank" rel="noopener">为什么觉得协程是趋势？</a></p>
<p><a href="http://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">编程珠玑番外篇-Q 协程的历史，现在和未来</a></p>
<p><a href="http://www.jackyshen.com/2015/05/21/async-operations-in-form-of-sync-programming-with-python-yielding/" target="_blank" rel="noopener">利用python yielding创建协程将异步编程同步化</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/16/openstack-keystone/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/openstack-keystone/" itemprop="url">
                  openstack系列 --keystone
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-16T15:01:55+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/16/openstack-keystone/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/16/openstack-keystone/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">keystone 是什么 </a></p>
<p><a href="#B">keystone 的架构 </a></p>
<p><a href="#C">token 的生成方式</a></p>
<p><a href="#D">可信计算部分介绍</a></p>
<p><a name="A"></a></p>
<h2 id="keystone-是什么"><a href="#keystone-是什么" class="headerlink" title="keystone 是什么"></a>keystone 是什么</h2><p>keystone 是 openstack 的认证服务模块（identy service）。 nova,glance,swift,cinder等其他服务通过keystone注册其服务的endpoint，针对这些服务的任何调用都需要经过keystone的身份认证，并获得服务的endpoint进行访问。</p>
<p>keystone 提供的服务可以概括为以下四个方面：</p>
<ul>
<li>Identity:对用户身份进行验证。用户的身份凭证通常是用户名和密码。</li>
<li>Token:Identity确认完用户身份后，会给用户提供一个token以请求后续的资源。而keystone也会提供针对token的验证。token大致有两类：一类是与Tenant(也就是project)无关的token，通过这个token，可以向keystone获取Tenant列表，用户选择要访问的Tenant,然后可以获取与该Tenant绑定的token,只有通过与某个特定Tenant绑定的token才能访问此Tenant中的资源。token有自己的过期时间，如果删除某个用户的访问权限，只要删除对应token即可。</li>
<li>Catalog:Catalog服务对外提供一个服务的查询目录，即可访问的endpoint列表。</li>
<li>Policy:一个基于规则的身份验证引擎。通过配置文件来定义各种动作与用户角色的匹配关系。该部分已作为Oslo的一部分进行开发维护。</li>
</ul>
<p>以创建虚拟机为例，keystone 的大致工作流程如下(注：以下内容摘自<a href="https://book.douban.com/subject/26374647/" target="_blank" rel="noopener">&lt;&lt;openstack设计与实现&gt;&gt;</a>)：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160918Keystone-process.png" alt="keystone process"></p>
<ul>
<li>用户Alice发送自己的凭证到keystone，keystone认证通过后，返回给Alice一个token以及服务目录。</li>
<li>Alice通过token请求keystone查询他所拥有的Tenant列表。（如果已经知道Tenant，略过以上两步）</li>
<li>Alice选择一个Tenant，发送自己的凭证给keystone申请token，keystone验证后，返回token2。</li>
<li>Alice选择endpoint并发送token2请求创建虚拟机，keystone验证token2(包括该token是否有效，是否有权限创建虚拟机等)成功后，把请求转发给Nova，并创建虚拟机。</li>
</ul>
<p><a name="B"></a></p>
<h2 id="keystone-的架构"><a href="#keystone-的架构" class="headerlink" title="keystone 的架构"></a>keystone 的架构</h2><p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160919-openstack-keystone-architecture.png" alt="keystone-architecture"></p>
<p>keystone还涉及另外一个子项目，keystonemiddleware,它提供了对token合法性进行验证的中间件。比如：客户端访问keystone提供的资源时用的是PKI类型的token，为了不必每次都需要keystone介入token的验证，我们通常会在本地节点上缓存相关证书和密钥，利用keystonemiddleware对token进行验证。</p>
<p>Keystone项目本身，除了后台的数据库，主要包括了一个处理restful请求的API服务进程。这些API涵盖了Identity,Token,Catalog,Policy等服务。这些不同的服务提供的功能则分别由后端Driver实现。</p>
<p><a name="C"></a></p>
<h2 id="token-的生成方式"><a href="#token-的生成方式" class="headerlink" title="token 的生成方式"></a>token 的生成方式</h2><p>在openstack F版本之前，token的生成方式只有UUID这一种方式（即由程序随机生成一段序列），但是在大规模的集群中，大量客户端并发请求的情况下，keystone的性能存在瓶颈（该版本还未引入keystonemiddleware）,所有的请求都要跟keystone交互。于是<br>PKI系统在随后的版本中引入，就可以做到本地检验而不用与keystone频繁交互。</p>
<p>PKI详细介绍，<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">check this!</a><br>此处简单介绍几个概念：</p>
<ul>
<li>Certificate Auth：即CA,认证中心，数字签证的签发机构，是PKI应用中权威的，可信任的第三方机构。</li>
<li>CA私钥：CA签发的非对称加密算法中的私钥。</li>
<li>CA公钥证书：包含CA的公钥信息。</li>
<li>签名私钥</li>
<li>签名公钥证书</li>
</ul>
<p>下图为UUID的token验证流程：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160919UUID-token-validation-flow-3.png" alt="uuid token valid"></p>
<p>下图为PKI的token验证流程：</p>
<p><img src="http://7xrnwq.com1.z0.glb.clouddn.com/20160919PKI-token-validation-flow-1.png" alt="pki token valid"></p>
<p><a name="D"></a></p>
<h2 id="可信计算部分介绍"><a href="#可信计算部分介绍" class="headerlink" title="可信计算部分介绍"></a>可信计算部分介绍</h2><p>在云计算环境中，可能会有成千上万个计算节点部署在不同的地方，可能有些云租户对安全的要求比较高，要求应用或虚拟机必须运行在验证为可信的节点上。openstack 在E版本时为此引入了可信计算池的概念。可信计算池的实现位于Nova项目。在FilterScheduler中加入了一个新的TrustedFilter,经过该filter的即认为是可信计算的节点。</p>
<p>那么可信节点是如何判定的呢？<br>计算节点采用基于Intel TXT 的TBoot进行可信启动，对主机的BIOS,VMM和操作系统进行完整性度量，并在得到来自认证服务的请求时将度量数据发送给认证服务。认证服务器部署基于OpenAttestation的认证服务，通过将来自主机的度量值与白名单数据库进行比对确定主机的可信状态。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://book.douban.com/subject/26374647/" target="_blank" rel="noopener">openstack 设计与实现 </a></p>
<p><a href="https://www.mirantis.com/blog/understanding-openstack-authentication-keystone-pki/" target="_blank" rel="noopener">Understanding OpenStack Authentication: Keystone PKI</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/16/secure-your-ubuntu-server/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/secure-your-ubuntu-server/" itemprop="url">
                  安全系列 --简单加固 ubuntu 服务器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-16T15:01:55+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/16/secure-your-ubuntu-server/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/16/secure-your-ubuntu-server/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">前言 </a></p>
<p><a href="#B">花五分钟的时间加固 ubuntu server </a></p>
<p><a href="#C">其他</a></p>
<p><a name="A"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逛v2ex的时候看到了一篇讨论 <a href="https://www.v2ex.com/t/306519#reply22" target="_blank" rel="noopener">在服务器上做什么加固策略</a>的帖子，想起自己之前看过的一篇文章，<a href="https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers" target="_blank" rel="noopener">My First 5 Minutes On A Server; Or, Essential Security for Linux Servers</a>，顺手写下这篇文章，权当记录，本篇的绝大部分内容都是出自这篇文章，强烈推荐，如果觉得TLDR,就接着往下翻吧。</p>
<p>安全，在大部分程序员潜意识里总是处于一种low priority的状态（参看此<a href="https://www.zhihu.com/question/20306241" target="_blank" rel="noopener">知乎链接</a>）。比如，我们搭建一个web server，会在第一时间去想用什么去部署，去实现，实现之后可能还会考虑高可用，可扩展等因素。而安全却总是会在最后才出现在我们的脑海里，甚至于直到出现安全事故才去关注。其实，我们拿到一台Linux服务器，只需要花些时间做一些安全方面的考量，做一些简单的措施就可以抵挡很大一部分攻击，提高攻击门槛。</p>
<p>那对于安全方面的措施，我比较推崇上文作者所说：简单有效。因为比较复杂的安全策略实施起来的增量收益可能会低于增加的大量人力物力资源。而且指不定还会引入其他的安全隐患。引用作者的话说：据我的经验来讲，大部分安全事故，要么是没有做足够的安全措施，要么是做了足够的安全措施，但没有更新维护导致出现漏洞。</p>
<p>Simplicity is the heart of good security.</p>
<p>下面就简单说下我们拿到一台服务器（或VPS）后需要做的一些安全加固措施。</p>
<p><a name="B"></a></p>
<h2 id="花五分钟的时间加固-ubuntu-server"><a href="#花五分钟的时间加固-ubuntu-server" class="headerlink" title="花五分钟的时间加固 ubuntu server"></a>花五分钟的时间加固 ubuntu server</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>本文中用的Linux发行版为 14.04。其他实验环境作者没有实践。<br>首先更改你的 root 密码为强类型密码。然后执行如下命令做一下升级：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="尽量不要使用root用户"><a href="#尽量不要使用root用户" class="headerlink" title="尽量不要使用root用户"></a>尽量不要使用root用户</h3><p>新增一个用户，当需要root权限时再用sudo暂时提升权限。新建用户的密码也要是强类型密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser example_user  <span class="comment">#新建 用户</span></span><br><span class="line">adduser example_user sudo  <span class="comment">#给新建用户添加sudo权限</span></span><br></pre></td></tr></table></figure>
<h3 id="使用SSH密钥认证登录"><a href="#使用SSH密钥认证登录" class="headerlink" title="使用SSH密钥认证登录"></a>使用SSH密钥认证登录</h3><p>利用ssh登录到Linux服务器有很多种方案，比较常用的就是用户名密码登录和SSH密钥认证的方式。<br>相对用户名密码登陆方式，后者是一种更安全的方案，因为前者容易受到暴力破解的威胁，而后者用暴力破解的方法不太实际。<br>首先需要在客户端产生公约密钥对。Linux下是如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>如果客户端是windows，可以利用putty等客户端实现。</p>
<p>创建完之后，我们会获取到两个文件，id_rsa.pub，和 id_rsa。也就是公钥文件和密钥文件。</p>
<p>接下来将公钥内容复制到服务器.ssh 目录下authorized_keys文件中。</p>
<h3 id="关闭SSH-密码服务器登陆"><a href="#关闭SSH-密码服务器登陆" class="headerlink" title="关闭SSH 密码服务器登陆"></a>关闭SSH 密码服务器登陆</h3><p>添加如下内容到 /etc/ssh/sshd_config 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br><span class="line">PasswordAuthentication no</span><br><span class="line">AllowUsers deploy@(your-ip) deploy@(another-ip-if-any) # 添加允许登录IP</span><br></pre></td></tr></table></figure>
<p>重启ssh服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<h3 id="添加防火墙"><a href="#添加防火墙" class="headerlink" title="添加防火墙"></a>添加防火墙</h3><p>添加防火墙有很多种方法，最简单的就是利用ubuntu 提供的ufw。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ufw allow from &#123;your-ip&#125; to any port 22 <span class="comment">#限定IP的端口</span></span><br><span class="line">ufw allow 80 <span class="comment">#打开80端口</span></span><br><span class="line">ufw allow 443 <span class="comment">#打开443端口</span></span><br><span class="line">ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></p>
<p> 当然要根据你的实际要求来打开对应的端口。除了ufw，还有iptables,ip6tables,以及最新的nftables等都可以实现防火墙。</p>
<h3 id="安装Fail2ban"><a href="#安装Fail2ban" class="headerlink" title="安装Fail2ban"></a>安装Fail2ban</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install fail2ban</span><br></pre></td></tr></table></figure>
<p>Fail2ban 会在服务端扫描日志并根据一些策略屏蔽一些有可疑行为的用户（IP）。官方介绍说的比较清楚：</p>
<blockquote>
<p>Fail2ban scans log files (e.g. /var/log/apache/error_log) and bans IPs that show the malicious signs – too many password failures, seeking for exploits, etc. Generally Fail2Ban is then used to update firewall rules to reject the IP addresses for a specified amount of time, although any arbitrary other action (e.g. sending an email) could also be configured. Out of the box Fail2Ban comes with filters for various services (apache, courier, ssh, etc).<br> Fail2Ban is able to reduce the rate of incorrect authentications attempts however it cannot eliminate the risk that weak authentication presents. Configure services to use only two factor or public/private authentication mechanisms if you really want to protect services.</p>
</blockquote>
<h3 id="设置安全自动升级"><a href="#设置安全自动升级" class="headerlink" title="设置安全自动升级"></a>设置安全自动升级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install unattended-upgrades</span><br><span class="line"></span><br><span class="line">vim /etc/apt/apt.conf.d/10periodic</span><br></pre></td></tr></table></figure>
<p>更新如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APT::Periodic::Update-Package-Lists <span class="string">"1"</span>;</span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages <span class="string">"1"</span>;</span><br><span class="line">APT::Periodic::AutocleanInterval <span class="string">"7"</span>;</span><br><span class="line">APT::Periodic::Unattended-Upgrade <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure>
<p>再更新下这个文件/etc/apt/apt.conf.d/50unattended-upgrades</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Unattended-Upgrade::Allowed-Origins &#123;</span><br><span class="line">        <span class="string">"Ubuntu lucid-security"</span>;</span><br><span class="line">//      <span class="string">"Ubuntu lucid-updates"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="安装Logwatch"><a href="#安装Logwatch" class="headerlink" title="安装Logwatch"></a>安装Logwatch</h3><p>Logwatch 是一个强大的日志解析和分析软件。它被设计用来给出一台服务器上所有的活动报告，可以以命令行的形式输出，或邮件发送。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install logwatch</span><br><span class="line"></span><br><span class="line">vim /etc/cron.daily/00logwatch</span><br></pre></td></tr></table></figure>
<p> 添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/logwatch --output mail --mailto <span class="built_in">test</span>@gmail.com --detail high</span><br></pre></td></tr></table></figure>
<p><a name="C"></a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其实原文在<a href="https://news.ycombinator.com/item?id=5316093" target="_blank" rel="noopener">hacking news</a> 上引发了一系列的讨论。比如有人就提出，我们拿到一台服务器的时候，第一件事不是加固，而是应该先安装配置管理工具（Puppet or Chef），利用配置管理工具才更有条理。其实lz认为还是看实际场景吧，配置管理工具确实方便，尤其是对于一些大型的项目，而对于只搭一个blog的vps，确实没有必要。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers" target="_blank" rel="noopener">My First 5 Minutes On A Server; Or, Essential Security for Linux Servers </a></p>
<p><a href="https://linode.com/docs/security/securing-your-server" target="_blank" rel="noopener">Securing Your Server</a></p>
<p><a href="https://news.ycombinator.com/item?id=5316093" target="_blank" rel="noopener">Hacking news</a></p>
<p><a href="https://www.v2ex.com/t/306519#reply22" target="_blank" rel="noopener">v2ex</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="pekingzcc" />
          <p class="site-author-name" itemprop="name">pekingzcc</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">96</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangchenchen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pekingzcc</span>
</div>


<div class="powered-by">
  powered by <a class="theme-link" href="https://hexo.io">Hexo</a> 
</div>

<div class="theme-info">
  theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'pekingzcc';
      var disqus_identifier = 'page/8/index.html';

      var disqus_title = "";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      

    </script>
  









  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
