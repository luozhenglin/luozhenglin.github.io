<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Solar">
<meta property="og:url" content="https://zhangchenchen.github.io/page/9/index.html">
<meta property="og:site_name" content="Solar">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Solar">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhangchenchen.github.io/page/9/"/>





  <title> Solar </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-92407570-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Solar</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/10/17/github-tips/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/17/github-tips/" itemprop="url">
                  git系列--关于github 的碎碎念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-17T22:01:21+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/17/github-tips/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/10/17/github-tips/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">github 快捷键 </a></p>
<p><a href="#B">github trending &amp;&amp; github subscribe </a></p>
<p><a href="#C">为开源项目贡献代码</a></p>
<p><a href="#D">git 常用命令</a></p>
<p><a name="A"></a></p>
<h2 id="github-快捷键"><a href="#github-快捷键" class="headerlink" title="github 快捷键"></a>github 快捷键</h2><p>逛v2ex的时候逛到了这个帖子，<a href="https://www.v2ex.com/t/313267#reply54" target="_blank" rel="noopener">录了几个有关 Github 的视频，我觉得你也应该知道这些</a>,很有意思,把视频看了一遍，都不是很长，强烈推荐。顺手记录下这些信息。<br>首先是github的一些快捷键：</p>
<ul>
<li><p>项目中搜索含有某个关键字的文件：在github 项目的code目录按下 “t”,即可进入搜索页面，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20161017github-search.jpg" alt="search"></p>
</li>
<li><p>列出github的快捷键：在项目目录按下 “？” 即可出现：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20161017shortcut.jpg" alt="github shortcut"></p>
<ul>
<li>进入 issue页面：按下“g” 与 “i”键，就是goto issue 的缩写</li>
<li>进入code页面：按下“g”与“c”键，goto code</li>
</ul>
<p>其他的按下“？”自己探索吧。</p>
<p><a name="B"></a></p>
<h2 id="github-trending-amp-amp-github-subscribe"><a href="#github-trending-amp-amp-github-subscribe" class="headerlink" title="github trending &amp;&amp; github subscribe"></a>github trending &amp;&amp; github subscribe</h2><ul>
<li>github trending:进入这个页面<a href="github.com/trending">github trending</a>就可以看到最近按照stars数排序靠前的比较优秀的项目，可以按照语言分类。</li>
<li>github subscribe:进入这个页面<a href="https://github.com/explore/subscribe" target="_blank" rel="noopener">github subscribe</a>,我们可以订阅我们关注的大牛，他们的动态会按周/月发送到你的邮箱。</li>
</ul>
<p><a name="C"></a></p>
<h2 id="为开源项目贡献代码"><a href="#为开源项目贡献代码" class="headerlink" title="为开源项目贡献代码"></a>为开源项目贡献代码</h2><p>关于这个，强烈推荐看下视频吧，直观易懂。这里简短记录下过程：</p>
<ul>
<li>fork and clone </li>
<li>github remote -add upstream <a href="mailto:ssh@xxxxxxxx.git" target="_blank" rel="noopener">ssh@xxxxxxxx.git</a> :标示我们fork的上级，master分支要与upstream分支保持一致</li>
<li>github checkout -b feature/bug-fixed : 创建并切换分支，在此分支上编码。</li>
<li>git add &amp;&amp; commit </li>
<li>git checkout master &amp;&amp; git pull upstream master：在push之前我们先要保证master与upstream一致。</li>
<li>git checkout feature/bug-fixed &amp;&amp; git rebase master：将在bug-fixed上的commit log 打到master分支的最上面。</li>
<li>git push origin featue/bug-fixed</li>
<li>git pull request: 现在可以向开源作者pull request了</li>
</ul>
<p><a name="D"></a></p>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><ul>
<li><p>切换分支后，清理本地目录：git reset –hard HEAD &amp;&amp; git clean -i </p>
</li>
<li><p>不详细写了，以后用得着直接去这个页面找吧：<br><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a></p>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.v2ex.com/t/313267#reply54" target="_blank" rel="noopener">v2ex</a></p>
<p><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/29/ceph-intro/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/ceph-intro/" itemprop="url">
                  ceph系列--ceph存储介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-29T14:24:25+08:00">
                2016-09-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/29/ceph-intro/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/29/ceph-intro/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">关于分布式存储</a></p>
<p><a href="#B">ceph 是什么 </a></p>
<p><a href="#B">ceph 架构</a></p>
<p><a href="#C">what makes ceph unique</a></p>
<p><a name="A"></a></p>
<h2 id="关于分布式存储"><a href="#关于分布式存储" class="headerlink" title="关于分布式存储"></a>关于分布式存储</h2><p>在了解ceph之前，我们最好还是先了解一下分布式存储的一些概念。分布式存储是随着存储容量的需求变大而出现的概念。由于存储需求变大，出现了两种解决方案，一种是scale up,采用容量更大，价格更昂贵的存储机器。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/scale-up.png" alt="scale-up"> </p>
<p>另一种是scale out,利用众多的普通存储机器（PC机）横向扩展成一个大的存储集群。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929scale-out.png" alt="scale-out"></p>
<p>第二种就是分布式存储的概念了。相对采用昂贵的专用商业存储设备来说，这种存储的性价比更高，但也因此引出了分布式存储几个比较棘手的问题，比如数据如何组织存储，如何保证高可用性，如何保证冗余数据的一致性，是否支持分布式事务，如何避免单点失败等等，这些概念可以参考这两篇文章，<a href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/" target="_blank" rel="noopener">分布式存储系统 知识体系</a>,<a href="http://webdam.inria.fr/Jorge/html/wdmch15.html" target="_blank" rel="noopener">An Introduction to Distributed Systems</a>。</p>
<p><a name="B"></a></p>
<h2 id="ceph-是什么"><a href="#ceph-是什么" class="headerlink" title="ceph 是什么"></a>ceph 是什么</h2><p>以下篇目是基于这场presentation，<a href="https://www.youtube.com/watch?v=7I9uxoEhUdY" target="_blank" rel="noopener">Ceph Intro &amp; Architectural Overview</a>.</p>
<p>我们首先看一下ceph 的设计哲学：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-ceph-design.png" alt="ceph design"></p>
<p>由此我们也可以看出ceph的一些特点：开源，社区驱动，可扩展，无单点故障，软件层面，自我管理。</p>
<p>那具体提供什么服务呢？看下图</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-ceph-service.png" alt="ceph service"></p>
<p>对应过来就是对象存储，块存储，文件系统存储。</p>
<p><a name="C"></a></p>
<h2 id="ceph-架构"><a href="#ceph-架构" class="headerlink" title="ceph 架构"></a>ceph 架构</h2><p>再从技术层面看下ceph架构</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/2016-09-29ceph-architect.png" alt="ceph-architect"></p>
<p>我们从底往上一层层的介绍，首先是RADOS,我们从上图的介绍中也可以看出，RADOS是一系列的节点，这些节点上跑着两种程序，跑着OSD程序的我们称为OSD节点（storage node），跑着MON程序的我们称为MON节点（monitor node）。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/2016-09-29-rados-1.png" alt="rados-1"></p>
<p>我们再详细看下OSD节点。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-rados-osd.png" alt="rados-osd"></p>
<p>每个OSD节点内，有多个磁盘disk,这些磁盘上是对应的文件系统（官网推荐 xfs），在往上就是我们的逻辑存储单元OSD，每个磁盘对应一个OSD。我们的数据就是存储在OSD里。<br>OSD与MON节点各自功能如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-OSD-MON.png" alt="OSD VS MON"></p>
<p>可以看出MON节点只负责集群状态的维护，具体存储交给OSD处理。</p>
<p>再看下LIBRADOS的作用。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929ceph-librados-service.png" alt="ceph-librados-service"></p>
<p>简而言之，就是为Application的调用提供了多种语言版本的接口。通信机制为SOCKET。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-librados.png" alt="librados"></p>
<p>再往上是RADOSGW.</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-radosgw-1.png" alt="RADOSGW-1"></p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-radosgw-2.png" alt="RADOSGW-1"></p>
<p>简而言之，就是在LIBRADOS提供的API的基础上进行封装对外提供对象存储的REST服务。</p>
<p>与之并列的是RBD，也就是ceph提供的块存储服务。我们最常用的就是attach到某台虚拟机上（如下图），Ross Turk还提到了另外两种用法，感兴趣可以去看一下。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929ceph-rbd-1.png" alt="ceph-rbd"></p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-ceph-rbd-2.png" alt="ceph-rbd"></p>
<p>关于ceph提供的文件系统因为用的不多，不再详述。</p>
<p><a name="D"></a></p>
<h2 id="what-makes-ceph-unique"><a href="#what-makes-ceph-unique" class="headerlink" title="what makes ceph unique"></a>what makes ceph unique</h2><p>第一个就是crush算法，一种计算寻址而非查找寻址的方法。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-crush-3.png" alt="crush-3"></p>
<p> 图中的placement group 有很重要的作用，有了它，我们底层添加节点或节点崩溃，ceph都会自动更新，而对用户是透明的。<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-crush-1.png" alt="crush-1"></p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160929-crush-2.png" alt="crush-2"></p>
<p>其次是 rbdlayering ,参考这里<a href="http://docs.ceph.com/docs/master/dev/rbd-layering/" target="_blank" rel="noopener">RBD LAYERING</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.youtube.com/watch?v=7I9uxoEhUdY" target="_blank" rel="noopener">Ceph Intro &amp; Architectural Overview</a></p>
<p><a href="http://www.slideshare.net/buildacloud/ceph-intro-and-architectural-overview-by-ross-turk" target="_blank" rel="noopener">Ceph Intro and Architectural Overview by Ross Turk</a></p>
<p><a href="http://www.cnblogs.com/sammyliu/p/4836014.html" target="_blank" rel="noopener">理解 OpenStack + Ceph （2）：Ceph 的物理和逻辑结构 [Ceph Architecture]</a></p>
<p><a href="http://docs.ceph.com/docs/master/" target="_blank" rel="noopener">ceph doc</a><br><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/26/python-yield-and coroutine/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/26/python-yield-and coroutine/" itemprop="url">
                  python系列--Python中的生成器以及协程的相关知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-26T14:24:25+08:00">
                2016-09-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/26/python-yield-and coroutine/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/26/python-yield-and coroutine/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">迭代器与生成器 </a></p>
<p><a href="#B">yield, send 关键字解析 </a></p>
<p><a href="#C">协程的一些知识</a></p>
<p><a name="A"></a></p>
<h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><p>在说生成器之前我们得先讨论一下迭代器的概念。</p>
<p>我们知道，对于一个可迭代的对象，我们可以通过 for <em> in </em> 的语句来进行迭代输出。这个可迭代的对象可以是一个list，string，文件等。其实我们深入这个可迭代的对象会发现，这些可迭代对象都实现了两个函数：<strong>iter</strong>() 和 next()。在我们调用list等这些可迭代对象的时候，需要把整个list数据全部读到内存里。这样就存在一个问题：list数据量小还可以，一旦变得特别大，内存就有可能被占满而导致运行缓慢甚至崩溃。这个时候我们想到，能不能只把我们需要的那个数据读入内存，调用next()的时候再把下一个数据读入内存呢。这就是生成器了。</p>
<p>一般来说，含有 yield 语句的函数就可叫做生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">ge = g()</span><br><span class="line">type(ge) <span class="comment">#ge 的类型为 'generator'</span></span><br><span class="line">dir(ge) <span class="comment">#列出ge包含的函数我们发现有__iter__() 和 next()</span></span><br><span class="line">ge.next()</span><br><span class="line">ge.next()</span><br><span class="line">ge.next()</span><br></pre></td></tr></table></figure>
<p>生成器也是一种迭代器，但我们只可以读取它一次，因为它并非把所有数据都存入内存中，而是实时地生成数据。上述例子当我们再次读取ge.next()后就会报错。</p>
<p>此处再略提一下生成器推导式：<br>我们知道Python中有各种集合的推导式，如下：</p>
<ul>
<li>列表推导式：my_list = [ f(x) for x in sequence if cond(x) ]</li>
<li>字典推导式：my_dict = { k(x): v(x) for x in sequence if cond(x) }</li>
<li>集合推导式：my_set = { f(x) for x in sequence if cond(x) }</li>
</ul>
<p>相应的，我们也可以用推导式来生成生成器，跟列表推导式类似，只需要将[]改为()：<br>my_generator = ( f(x) for x in sequence if cond(x) )</p>
<p><a name="B"></a></p>
<h2 id="yield-send-关键字解析"><a href="#yield-send-关键字解析" class="headerlink" title="yield, send 关键字解析"></a>yield, send 关键字解析</h2><p>由上文可以看到，yield关键字是理解生成器的关键。那么yield什么意思呢？我们来详细解释一下。<br>yield 关键字有点类似我们平常写程序用到的return。但是程序运行到return的时候就会返回，运行完毕。而运行到yield的时候也会返回，但会保存上下文之后再返回，等到下次再次唤醒该程序的时候恢复上下文，继续从此运行，直到碰到下一次yield。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator :</span><br><span class="line">   print(i) <span class="comment">#输出0,1,4</span></span><br></pre></td></tr></table></figure>
<p>首先我们创建了一个生成器mygenerator，注意，此时程序并不执行，只是创建了一个生成器。接着是一个for循环,fou循环其实就是执行了一个next()函数，此时进入生成器获取第一个i就是0乘以0，也就是0。返回并输出。再次循环，进入生成器，以此类推。这个例子可能不是特别直接，只是说明一下运行的逻辑顺序，下文中我们有一个更为直接的实例。</p>
<p>我们先看一下send()函数再将两个函数放在一个例子中说明一下。</p>
<p>在调用生成器时，除了next()方法，我们还可以用send()方法唤醒生成器，而且send(args),在唤醒生成器的同时会把参数 args传给指定的数据。如下例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span>     <span class="comment">#定义一个生成器函数</span></span><br><span class="line">     <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">         val = <span class="keyword">yield</span> <span class="comment"># val接受send()传过来的的参数并赋值</span></span><br><span class="line">         <span class="keyword">yield</span> val*<span class="number">10</span> </span><br><span class="line"></span><br><span class="line">g = f() <span class="comment">#新建一个生成器</span></span><br><span class="line">g.next() <span class="comment">#触发生成器，生成器执行到val=yield ，保存上下文退出，等待传值</span></span><br><span class="line">g.send(<span class="number">1</span>) <span class="comment"># 触发生成器，生成器继续执行，赋值val = 1，执行到yield val*10，保存上下文，,返回10，退出。</span></span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">#同上</span></span><br><span class="line">g.send(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">g.next()</span><br><span class="line">g.send(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，我们在用send()之前必须保证生成器已经执行到yield,也就是说生成器已经被触发过一次，我们可以用send(none)来实现。其实，next()跟send(none)效果是一样的。</p>
<p>接下来我们看一个比较复杂的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2016-09-22 16:40:36</span></span><br><span class="line"><span class="comment"># @Author  : Zhang Chen (pekingzcc@gmail.com)</span></span><br><span class="line"><span class="comment"># @Link    : zhangchenchen.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Into genaration :counting down from"</span>, n</span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Genaration: ###loops from here###"</span></span><br><span class="line">        newvalue = (<span class="keyword">yield</span> n)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Gerenation: newvalue is"</span>,newvalue</span><br><span class="line">        <span class="comment"># If a new value got sent in, reset n with it</span></span><br><span class="line">        <span class="keyword">if</span> newvalue <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            n = newvalue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    c = countdown(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Main function begin from here "</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> c:</span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Main function: x is"</span>, x</span><br><span class="line">         <span class="keyword">if</span> x == <span class="number">5</span>:</span><br><span class="line">            c.send(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子看明白了，yield与send的用法就理解的差不多了。<br>我们首先看一下执行结果：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160926python-yield.png" alt="python-yield"></p>
<p>接下来分析一下：我们从main 函数开始，先创建了一个生成器（此时并未执行），接着输出main函数开始的语句。接着进入for循环，注意，遇到for循环就相当于执行了一次next(),所以进入生成器输出“Into genaration :counting down from 5”，继续运行，进入生成器的for循环，输出“Genaration: ###loops from here###”，继续往下，碰到yield n ，保存上下文，退出并返回n(此时是5)到main函数，主函数输出“Main function: x is 5”，进入条件语句，c.send(5)触发生成器，再次进入生成器，赋值newvalue为3，接着输出“Gerenation: newvalue is 3” ，赋值n = newvalue =3 ,继续循环输出“Genaration: ###loops from here###”，碰到yield n ,返回main函数，注意，此时main函数又进入到for循环，所以再次进入生成器，但是没有send()数据传过来，也可以理解为send(none),所以输出“Gerenation: newvalue is none”,接着执行n-1 ,n变为2。继续循环，输出“Genaration: ###loops from here###”。。。。。</p>
<p><a name="C"></a></p>
<h2 id="协程的一些知识"><a href="#协程的一些知识" class="headerlink" title="协程的一些知识"></a>协程的一些知识</h2><p>在了解协程之前，我们需要先从进程，线程说起。我们知道，进程的出现是为了并发，在一台机器上同时运行多个程序（当然，内部实现可能是多CPU并行，也有可能是单CPU时间分片，但在外部看来就是多个程序一起运行），进程的切换需要陷入内核，由OS来进行切换。一切换进程得反复进入内核，置换掉一大堆状态，这样，进程数一高，就会吃掉很多的系统资源。为了解决这个问题，就出现了线程的概念。</p>
<p>一个进程里可以有多个线程，这样就能处理多个逻辑，当某个线程阻塞的时候，可以切换线程到另一个线程。因为线程是共享附属进程的资源的，它们件的切换相对要比进程间的切换消耗的资源要少很多。但之后，问题又来了，操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还需要做这些数据的恢复操作，所以线程多了之后，它们之间的切换也非常耗性能。</p>
<p>协程的概念就来了，既然线程切换费资源，那我们干脆自己做逻辑流的切换，不用交给OS处理。注意，这里经常提到的是切换，具体到应用场景就是IO密集型场景。在cpu密集型的场景中协程的意义就没有那么大了。在IO处理时，我们有同步，异步两种处理方式，关于IO模型，可以<a href="http://www.jianshu.com/p/55eb83d60ab1" target="_blank" rel="noopener">check this</a> 。在异步处理IO时，我们需要写回调函数来实现异步，这种写法是比较反人类的，可读性比较差。协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。协程的切换很轻，消耗资源少。协程通过这种对异步IO的封装既保留了性能也保证了代码的 容易编写和可读性。</p>
<p>其实协程不是一个新生的事物，它在很早之前就出现了，只不过最近因为在一些动态语言的世界里大放异彩。对其历史感兴趣的<a href="http://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">check this</a>。</p>
<p>再简单说一下Python中的协程，其实Python中的协程跟yield关键字是分不开的。只要含有yield的函数都可以认为是一个协程，利用协程实现的生产者消费者如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""返回0到9之间的3个随机数，模拟异步操作"""</span></span><br><span class="line">    <span class="keyword">return</span> random.sample(range(<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示每次传入的整数列表的动态平均值"""</span></span><br><span class="line">    running_sum = <span class="number">0</span></span><br><span class="line">    data_items_seen = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'Waiting to consume'</span>)</span><br><span class="line">        data = <span class="keyword">yield</span></span><br><span class="line">        data_items_seen += len(data)</span><br><span class="line">        running_sum += sum(data)</span><br><span class="line">        print(<span class="string">'Consumed, the running average is &#123;&#125;'</span>.format(running_sum / float(data_items_seen)))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(consumer)</span>:</span></span><br><span class="line">    <span class="string">"""产生序列集合，传递给消费函数（consumer）"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = get_data()</span><br><span class="line">        print(<span class="string">'Produced &#123;&#125;'</span>.format(data))</span><br><span class="line">        consumer.send(data)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    consumer = consume()</span><br><span class="line">    consumer.send(<span class="keyword">None</span>) </span><br><span class="line">    producer = produce(consumer)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">'Producing...'</span>)</span><br><span class="line">        next(producer)</span><br></pre></td></tr></table></figure>
<p>利用协程的Python库比较常见的是Greenlet库，它是以C扩展模块形式接入Python的轻量级协程，将一些原本同步运行的网络库以mockey_patch的方式进行了重写。Greenlets全部运行在主程序操作系统进程的内部，它们被协作式地调度。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf" target="_blank" rel="noopener">A Curious Course on Coroutines and Concurrency</a></p>
<p><a href="https://www.oschina.net/translate/improve-your-python-yield-and-generators-explained" target="_blank" rel="noopener">提高你的Python: 解释‘yield’和‘Generators（生成器）</a></p>
<p><a href="http://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html" target="_blank" rel="noopener">(译)Python关键字yield的解释(stackoverflow)</a></p>
<p><a href="https://segmentfault.com/a/1190000001813992" target="_blank" rel="noopener">Python 中的进程、线程、协程、同步、异步、回调</a></p>
<p><a href="http://codingpy.com/article/what-is-generator-comprehension/" target="_blank" rel="noopener">什么是Python中的生成器推导式？</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/start-learning-python/215.html" target="_blank" rel="noopener">生成器</a></p>
<p><a href="http://manjusaka.itscoder.com/2016/09/11/something-about-yield-in-python/" target="_blank" rel="noopener">聊聊 Python 中生成器和协程那点事儿</a></p>
<p><a href="http://www.bogotobogo.com/python/python_function_with_generator_send_method_yield_keyword_iterator_next.php" target="_blank" rel="noopener">GENERATOR.SEND() WITH YIELD</a></p>
<p><a href="http://blog.kazaff.me/2016/05/29/%E4%BA%86%E8%A7%A3%E5%8D%8F%E7%A8%8B(coroutine" target="_blank" rel="noopener">了解协程（Coroutine）</a>/)</p>
<p><a href="https://www.zhihu.com/question/20511233" target="_blank" rel="noopener">协程的好处是什么？</a></p>
<p><a href="https://www.zhihu.com/question/32218874/answer/55469714" target="_blank" rel="noopener">为什么觉得协程是趋势？</a></p>
<p><a href="http://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">编程珠玑番外篇-Q 协程的历史，现在和未来</a></p>
<p><a href="http://www.jackyshen.com/2015/05/21/async-operations-in-form-of-sync-programming-with-python-yielding/" target="_blank" rel="noopener">利用python yielding创建协程将异步编程同步化</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/16/openstack-keystone/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/openstack-keystone/" itemprop="url">
                  openstack系列 --keystone
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-16T15:01:55+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/16/openstack-keystone/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/16/openstack-keystone/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">keystone 是什么 </a></p>
<p><a href="#B">keystone 的架构 </a></p>
<p><a href="#C">token 的生成方式</a></p>
<p><a href="#D">可信计算部分介绍</a></p>
<p><a name="A"></a></p>
<h2 id="keystone-是什么"><a href="#keystone-是什么" class="headerlink" title="keystone 是什么"></a>keystone 是什么</h2><p>keystone 是 openstack 的认证服务模块（identy service）。 nova,glance,swift,cinder等其他服务通过keystone注册其服务的endpoint，针对这些服务的任何调用都需要经过keystone的身份认证，并获得服务的endpoint进行访问。</p>
<p>keystone 提供的服务可以概括为以下四个方面：</p>
<ul>
<li>Identity:对用户身份进行验证。用户的身份凭证通常是用户名和密码。</li>
<li>Token:Identity确认完用户身份后，会给用户提供一个token以请求后续的资源。而keystone也会提供针对token的验证。token大致有两类：一类是与Tenant(也就是project)无关的token，通过这个token，可以向keystone获取Tenant列表，用户选择要访问的Tenant,然后可以获取与该Tenant绑定的token,只有通过与某个特定Tenant绑定的token才能访问此Tenant中的资源。token有自己的过期时间，如果删除某个用户的访问权限，只要删除对应token即可。</li>
<li>Catalog:Catalog服务对外提供一个服务的查询目录，即可访问的endpoint列表。</li>
<li>Policy:一个基于规则的身份验证引擎。通过配置文件来定义各种动作与用户角色的匹配关系。该部分已作为Oslo的一部分进行开发维护。</li>
</ul>
<p>以创建虚拟机为例，keystone 的大致工作流程如下(注：以下内容摘自<a href="https://book.douban.com/subject/26374647/" target="_blank" rel="noopener">&lt;&lt;openstack设计与实现&gt;&gt;</a>)：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160918Keystone-process.png" alt="keystone process"></p>
<ul>
<li>用户Alice发送自己的凭证到keystone，keystone认证通过后，返回给Alice一个token以及服务目录。</li>
<li>Alice通过token请求keystone查询他所拥有的Tenant列表。（如果已经知道Tenant，略过以上两步）</li>
<li>Alice选择一个Tenant，发送自己的凭证给keystone申请token，keystone验证后，返回token2。</li>
<li>Alice选择endpoint并发送token2请求创建虚拟机，keystone验证token2(包括该token是否有效，是否有权限创建虚拟机等)成功后，把请求转发给Nova，并创建虚拟机。</li>
</ul>
<p><a name="B"></a></p>
<h2 id="keystone-的架构"><a href="#keystone-的架构" class="headerlink" title="keystone 的架构"></a>keystone 的架构</h2><p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160919-openstack-keystone-architecture.png" alt="keystone-architecture"></p>
<p>keystone还涉及另外一个子项目，keystonemiddleware,它提供了对token合法性进行验证的中间件。比如：客户端访问keystone提供的资源时用的是PKI类型的token，为了不必每次都需要keystone介入token的验证，我们通常会在本地节点上缓存相关证书和密钥，利用keystonemiddleware对token进行验证。</p>
<p>Keystone项目本身，除了后台的数据库，主要包括了一个处理restful请求的API服务进程。这些API涵盖了Identity,Token,Catalog,Policy等服务。这些不同的服务提供的功能则分别由后端Driver实现。</p>
<p><a name="C"></a></p>
<h2 id="token-的生成方式"><a href="#token-的生成方式" class="headerlink" title="token 的生成方式"></a>token 的生成方式</h2><p>在openstack F版本之前，token的生成方式只有UUID这一种方式（即由程序随机生成一段序列），但是在大规模的集群中，大量客户端并发请求的情况下，keystone的性能存在瓶颈（该版本还未引入keystonemiddleware）,所有的请求都要跟keystone交互。于是<br>PKI系统在随后的版本中引入，就可以做到本地检验而不用与keystone频繁交互。</p>
<p>PKI详细介绍，<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">check this!</a><br>此处简单介绍几个概念：</p>
<ul>
<li>Certificate Auth：即CA,认证中心，数字签证的签发机构，是PKI应用中权威的，可信任的第三方机构。</li>
<li>CA私钥：CA签发的非对称加密算法中的私钥。</li>
<li>CA公钥证书：包含CA的公钥信息。</li>
<li>签名私钥</li>
<li>签名公钥证书</li>
</ul>
<p>下图为UUID的token验证流程：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160919UUID-token-validation-flow-3.png" alt="uuid token valid"></p>
<p>下图为PKI的token验证流程：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160919PKI-token-validation-flow-1.png" alt="pki token valid"></p>
<p><a name="D"></a></p>
<h2 id="可信计算部分介绍"><a href="#可信计算部分介绍" class="headerlink" title="可信计算部分介绍"></a>可信计算部分介绍</h2><p>在云计算环境中，可能会有成千上万个计算节点部署在不同的地方，可能有些云租户对安全的要求比较高，要求应用或虚拟机必须运行在验证为可信的节点上。openstack 在E版本时为此引入了可信计算池的概念。可信计算池的实现位于Nova项目。在FilterScheduler中加入了一个新的TrustedFilter,经过该filter的即认为是可信计算的节点。</p>
<p>那么可信节点是如何判定的呢？<br>计算节点采用基于Intel TXT 的TBoot进行可信启动，对主机的BIOS,VMM和操作系统进行完整性度量，并在得到来自认证服务的请求时将度量数据发送给认证服务。认证服务器部署基于OpenAttestation的认证服务，通过将来自主机的度量值与白名单数据库进行比对确定主机的可信状态。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://book.douban.com/subject/26374647/" target="_blank" rel="noopener">openstack 设计与实现 </a></p>
<p><a href="https://www.mirantis.com/blog/understanding-openstack-authentication-keystone-pki/" target="_blank" rel="noopener">Understanding OpenStack Authentication: Keystone PKI</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/16/secure-your-ubuntu-server/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/secure-your-ubuntu-server/" itemprop="url">
                  安全系列 --简单加固 ubuntu 服务器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-16T15:01:55+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/16/secure-your-ubuntu-server/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/16/secure-your-ubuntu-server/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="#A">前言 </a></p>
<p><a href="#B">花五分钟的时间加固 ubuntu server </a></p>
<p><a href="#C">其他</a></p>
<p><a name="A"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逛v2ex的时候看到了一篇讨论 <a href="https://www.v2ex.com/t/306519#reply22" target="_blank" rel="noopener">在服务器上做什么加固策略</a>的帖子，想起自己之前看过的一篇文章，<a href="https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers" target="_blank" rel="noopener">My First 5 Minutes On A Server; Or, Essential Security for Linux Servers</a>，顺手写下这篇文章，权当记录，本篇的绝大部分内容都是出自这篇文章，强烈推荐，如果觉得TLDR,就接着往下翻吧。</p>
<p>安全，在大部分程序员潜意识里总是处于一种low priority的状态（参看此<a href="https://www.zhihu.com/question/20306241" target="_blank" rel="noopener">知乎链接</a>）。比如，我们搭建一个web server，会在第一时间去想用什么去部署，去实现，实现之后可能还会考虑高可用，可扩展等因素。而安全却总是会在最后才出现在我们的脑海里，甚至于直到出现安全事故才去关注。其实，我们拿到一台Linux服务器，只需要花些时间做一些安全方面的考量，做一些简单的措施就可以抵挡很大一部分攻击，提高攻击门槛。</p>
<p>那对于安全方面的措施，我比较推崇上文作者所说：简单有效。因为比较复杂的安全策略实施起来的增量收益可能会低于增加的大量人力物力资源。而且指不定还会引入其他的安全隐患。引用作者的话说：据我的经验来讲，大部分安全事故，要么是没有做足够的安全措施，要么是做了足够的安全措施，但没有更新维护导致出现漏洞。</p>
<p>Simplicity is the heart of good security.</p>
<p>下面就简单说下我们拿到一台服务器（或VPS）后需要做的一些安全加固措施。</p>
<p><a name="B"></a></p>
<h2 id="花五分钟的时间加固-ubuntu-server"><a href="#花五分钟的时间加固-ubuntu-server" class="headerlink" title="花五分钟的时间加固 ubuntu server"></a>花五分钟的时间加固 ubuntu server</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>本文中用的Linux发行版为 14.04。其他实验环境作者没有实践。<br>首先更改你的 root 密码为强类型密码。然后执行如下命令做一下升级：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="尽量不要使用root用户"><a href="#尽量不要使用root用户" class="headerlink" title="尽量不要使用root用户"></a>尽量不要使用root用户</h3><p>新增一个用户，当需要root权限时再用sudo暂时提升权限。新建用户的密码也要是强类型密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser example_user  <span class="comment">#新建 用户</span></span><br><span class="line">adduser example_user sudo  <span class="comment">#给新建用户添加sudo权限</span></span><br></pre></td></tr></table></figure>
<h3 id="使用SSH密钥认证登录"><a href="#使用SSH密钥认证登录" class="headerlink" title="使用SSH密钥认证登录"></a>使用SSH密钥认证登录</h3><p>利用ssh登录到Linux服务器有很多种方案，比较常用的就是用户名密码登录和SSH密钥认证的方式。<br>相对用户名密码登陆方式，后者是一种更安全的方案，因为前者容易受到暴力破解的威胁，而后者用暴力破解的方法不太实际。<br>首先需要在客户端产生公约密钥对。Linux下是如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>如果客户端是windows，可以利用putty等客户端实现。</p>
<p>创建完之后，我们会获取到两个文件，id_rsa.pub，和 id_rsa。也就是公钥文件和密钥文件。</p>
<p>接下来将公钥内容复制到服务器.ssh 目录下authorized_keys文件中。</p>
<h3 id="关闭SSH-密码服务器登陆"><a href="#关闭SSH-密码服务器登陆" class="headerlink" title="关闭SSH 密码服务器登陆"></a>关闭SSH 密码服务器登陆</h3><p>添加如下内容到 /etc/ssh/sshd_config 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br><span class="line">PasswordAuthentication no</span><br><span class="line">AllowUsers deploy@(your-ip) deploy@(another-ip-if-any) # 添加允许登录IP</span><br></pre></td></tr></table></figure>
<p>重启ssh服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<h3 id="添加防火墙"><a href="#添加防火墙" class="headerlink" title="添加防火墙"></a>添加防火墙</h3><p>添加防火墙有很多种方法，最简单的就是利用ubuntu 提供的ufw。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ufw allow from &#123;your-ip&#125; to any port 22 <span class="comment">#限定IP的端口</span></span><br><span class="line">ufw allow 80 <span class="comment">#打开80端口</span></span><br><span class="line">ufw allow 443 <span class="comment">#打开443端口</span></span><br><span class="line">ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></p>
<p> 当然要根据你的实际要求来打开对应的端口。除了ufw，还有iptables,ip6tables,以及最新的nftables等都可以实现防火墙。</p>
<h3 id="安装Fail2ban"><a href="#安装Fail2ban" class="headerlink" title="安装Fail2ban"></a>安装Fail2ban</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install fail2ban</span><br></pre></td></tr></table></figure>
<p>Fail2ban 会在服务端扫描日志并根据一些策略屏蔽一些有可疑行为的用户（IP）。官方介绍说的比较清楚：</p>
<blockquote>
<p>Fail2ban scans log files (e.g. /var/log/apache/error_log) and bans IPs that show the malicious signs – too many password failures, seeking for exploits, etc. Generally Fail2Ban is then used to update firewall rules to reject the IP addresses for a specified amount of time, although any arbitrary other action (e.g. sending an email) could also be configured. Out of the box Fail2Ban comes with filters for various services (apache, courier, ssh, etc).<br> Fail2Ban is able to reduce the rate of incorrect authentications attempts however it cannot eliminate the risk that weak authentication presents. Configure services to use only two factor or public/private authentication mechanisms if you really want to protect services.</p>
</blockquote>
<h3 id="设置安全自动升级"><a href="#设置安全自动升级" class="headerlink" title="设置安全自动升级"></a>设置安全自动升级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install unattended-upgrades</span><br><span class="line"></span><br><span class="line">vim /etc/apt/apt.conf.d/10periodic</span><br></pre></td></tr></table></figure>
<p>更新如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APT::Periodic::Update-Package-Lists <span class="string">"1"</span>;</span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages <span class="string">"1"</span>;</span><br><span class="line">APT::Periodic::AutocleanInterval <span class="string">"7"</span>;</span><br><span class="line">APT::Periodic::Unattended-Upgrade <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure>
<p>再更新下这个文件/etc/apt/apt.conf.d/50unattended-upgrades</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Unattended-Upgrade::Allowed-Origins &#123;</span><br><span class="line">        <span class="string">"Ubuntu lucid-security"</span>;</span><br><span class="line">//      <span class="string">"Ubuntu lucid-updates"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="安装Logwatch"><a href="#安装Logwatch" class="headerlink" title="安装Logwatch"></a>安装Logwatch</h3><p>Logwatch 是一个强大的日志解析和分析软件。它被设计用来给出一台服务器上所有的活动报告，可以以命令行的形式输出，或邮件发送。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install logwatch</span><br><span class="line"></span><br><span class="line">vim /etc/cron.daily/00logwatch</span><br></pre></td></tr></table></figure>
<p> 添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/logwatch --output mail --mailto <span class="built_in">test</span>@gmail.com --detail high</span><br></pre></td></tr></table></figure>
<p><a name="C"></a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其实原文在<a href="https://news.ycombinator.com/item?id=5316093" target="_blank" rel="noopener">hacking news</a> 上引发了一系列的讨论。比如有人就提出，我们拿到一台服务器的时候，第一件事不是加固，而是应该先安装配置管理工具（Puppet or Chef），利用配置管理工具才更有条理。其实lz认为还是看实际场景吧，配置管理工具确实方便，尤其是对于一些大型的项目，而对于只搭一个blog的vps，确实没有必要。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers" target="_blank" rel="noopener">My First 5 Minutes On A Server; Or, Essential Security for Linux Servers </a></p>
<p><a href="https://linode.com/docs/security/securing-your-server" target="_blank" rel="noopener">Securing Your Server</a></p>
<p><a href="https://news.ycombinator.com/item?id=5316093" target="_blank" rel="noopener">Hacking news</a></p>
<p><a href="https://www.v2ex.com/t/306519#reply22" target="_blank" rel="noopener">v2ex</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/06/openstack-cinder/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/06/openstack-cinder/" itemprop="url">
                  openstack 系列 --cinder
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-06T15:01:55+08:00">
                2016-09-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/06/openstack-cinder/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/06/openstack-cinder/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>在学习一个新东西的时候，我们其实默认是带着问题去学习的。但当我们真正在卷帙繁多的互联网或者书籍里获取信息时。之前的问题往往就淡化了，反而更多的是跟着资料所给的思路去学习。这样有好处也有坏处，好处是我们不用费心去思考，而坏处也是如此，不用思考带来的后果就是这些信息虽然当时我们理解了，但很难在我们的脑海中建立知识图谱，比较容易遗忘。</p>
<p>所以以后我会在写文章的时候先把问题具象化，从自己问题的角度出发去寻找答案.</p>
<p>本篇我们的主题是openstack的块存储项目cinder,那么第一个问题自然是 <em>cinder是干什么用的？</em> 由这个问题出发，我们逐渐引出 <em>cinder如何实现？</em> ，<em>cinder的具体功能</em> 。</p>
<p><a href="#A">cinder是干什么用的 </a></p>
<p><a href="#B">cinder如何实现 </a></p>
<p><a href="#C">cinder的具体功能</a></p>
<p><a name="A"></a></p>
<h2 id="cinder是干什么用的"><a href="#cinder是干什么用的" class="headerlink" title="cinder是干什么用的"></a>cinder是干什么用的</h2><p>openstack中创建虚拟机的时候是附带一块硬盘的，但这块硬盘随着虚拟机的destroy也相应的删除了。所以，openstack推出了两种应付持久存储的解决方案，一个是之前我们提过的对象存储swift，一个就是现在我们讲的块存储cinder。<br>块存储,对象存储的概念我们<a href="http://zhangchenchen.github.io/2016/09/02/openstack-swift/">之前</a>已介绍过，不再赘述。<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160907openstack-storage-compare.jpg" alt="存储对比"><br>需要说明的是，cinder并不是新开发的一个块设备存储系统，它更像是一个资源管理系统，对不同的存储后端进行封装，以统一的API形式向虚拟机提供持久块存储资源。对于不同的存储后端，它采用插件的形式，结合不同的后端存储的驱动提供块存储服务。</p>
<p><a name="B"></a></p>
<h2 id="cinder如何实现"><a href="#cinder如何实现" class="headerlink" title="cinder如何实现"></a>cinder如何实现</h2><p>首先看一下cinder的主要组件：<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160907-openstack-cinder-part.jpg" alt="cinder architecture"><br>简单介绍下这几个组件：</p>
<ul>
<li><p>cinder-api: 负责接受和处理外界的API请求，并将请求放入RabbitMQ队列，交由其他程序执行。</p>
</li>
<li><p>cinder-scheduler: 在多个存储节点的情况下，新建或迁移volume的时候由该程序依据指定的算法选出合适的节点。算法有过滤算法和权重算法两种。</p>
</li>
<li><p>cinder-volume： 运行在存储节点上，管理存储空间，处理cinder数据库维护状态的读写请求，通过消息队列和直接在块存储设备或软件上与其他进程交互。每个存储节点都有一个Volume Service，若干个这样的存储节点联合起来可以构成一个存储资源池。cinder-volume为后端的volume provider 定义了统一的 driver 接口，volume provider 只需要实现这些接口，就可以 driver 的形式即插即用到 OpenStack 中。</p>
</li>
</ul>
<p>接下来介绍下这种插件机制以及后端的具体存储：<br>后端存储大致可以分为两类，一类是软件实现的存储系统，比如LVM,ceph,sheepdog等。另一类是商用的硬件支持的专业存储系统，比如IBM,HP,EMC等公司的专业存储系统。</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160907openstack-cinder-storage.jpg" alt="不同存储"></p>
<p>以LVM 为例：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160907-cinder-lvm.jpg" alt="lvm"></p>
<p>此处简单介绍下iSCSI协议,引自 <a href="https://zh.wikipedia.org/wiki/ISCSI" target="_blank" rel="noopener">wiki</a>:</p>
<blockquote>
<p>iSCSI利用了TCP/IP的port 860 和 3260 作为沟通的渠道。透过两部计算机之间利用iSCSI的协议来交换SCSI命令，让计算机可以透过高速的局域网集线来把SAN模拟成为本地的储存装置。iSCSI使用 TCP/IP 协议（一般使用TCP端口860和3260）。 本质上，iSCSI 让两个主机通过 IP 网络相互协商然后交换 SCSI 命令。这样一来，iSCSI 就是用广域网仿真了一个常用的高性能本地存储总线，从而创建了一个存储局域网（SAN）。不像某些 SAN 协议，iSCSI 不需要专用的电缆；它可以在已有的交换和 IP 基础架构上运行。然而，如果不使用专用的网络或者子网（ LAN 或者 VLAN ），iSCSI SAN 的部署性能可能会严重下降。于是，iSCSI 常常被认为是光纤通道（Fiber Channel）的一个低成本替代方法，而光纤通道是需要专用的基础架构的。但是，基于以太网的光纤通道（FCoE）则不需要专用的基础架构。</p>
</blockquote>
<p>其他商用存储系统：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160907-cinder-other%20-storage.jpg" alt="others"></p>
<p>两者对比，<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fevents.linuxfoundation.org%2Fsites%2Fevents%2Ffiles%2Fslides%2FCloudOpenJapan2014-Kimura_0.pdf" target="_blank" rel="noopener">check this!</a></p>
<p><a name="C"></a></p>
<h2 id="cinder的具体功能"><a href="#cinder的具体功能" class="headerlink" title="cinder的具体功能"></a>cinder的具体功能</h2><p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160907-cinder-functure.jpg" alt="cinder functure"></p>
<p>从代码层面了解具体实现的流程，<a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/Create_Volume_%E6%93%8D%E4%BD%9C_Part_III_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_OpenStack_52?lang=en" target="_blank" rel="noopener">check this!</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.cnblogs.com/sammyliu/p/4219974.html" target="_blank" rel="noopener">探索 OpenStack 之（9）：深入块存储服务Cinder </a></p>
<p><a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/%E7%90%86%E8%A7%A3_Cinder_%E6%9E%B6%E6%9E%84_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_OpenStack_45?lang=en" target="_blank" rel="noopener">每天五分钟玩转openstack </a></p>
<p><a href="https://book.douban.com/subject/26374647/" target="_blank" rel="noopener">openstack 设计与实现</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/05/python-web-intro/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/python-web-intro/" itemprop="url">
                  python系列--python web 运行与部署
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-05T14:58:25+08:00">
                2016-09-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/05/python-web-intro/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/05/python-web-intro/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p>在学习一个新东西的时候，我们其实默认是带着问题去学习的。但当我们真正在卷帙繁多的互联网或者书籍里获取信息时。之前的问题往往就淡化了，反而更多的是跟着资料所给的思路去学习。这样有好处也有坏处，好处是我们不用费心去思考，而坏处也是如此，不用思考带来的后果就是这些信息虽然当时我们理解了，但很难在我们的脑海中建立知识图谱，比较容易遗忘。</p>
<p>所以以后我会在写文章的时候先把问题具象化，从自己问题的角度出发去寻找答案。</p>
<p>本篇我们的问题从 <em>python web 是如何跑起来的？</em> 开始，一步步探究由此问题引起的其他内容。</p>
<p><a href="#A">python web 是如何跑起来的？ </a></p>
<p><a href="#B">探究 WSGI </a></p>
<p><a href="#C">探究 python web framework</a></p>
<p><a href="#D">探究 python web server</a></p>
<p><a href="#E">常见 python web生产部署环境</a></p>
<p><a name="A"></a></p>
<h2 id="python-web-是如何跑起来的？"><a href="#python-web-是如何跑起来的？" class="headerlink" title="python web 是如何跑起来的？"></a>python web 是如何跑起来的？</h2><p>要知道python web 是如何跑起来的，我们首先要知道一个http请求的生命周期。<br>一个http请求从浏览器发出，在服务端被http server接收，这个http server对请求进行解析，如果是一些图片，文本等静态资源，它就会根据路径去寻找对应的资源并返回。如果是请求的动态资源，比如jsp/php等，它就会把相应的http请求转发给一个web server,由web server对请求进行解析并处理，并最终返回一个 http response。这就是一个http请求的大致周期。<br>接下来对应到python web中，当web server 接收到一个请求时，它当然是解析请求并把该请求映射到我们写的对应的处理逻辑中。我们的处理逻辑处理完成后，再将结果由web server 转发出去。那web werver 与 我们写的处理逻辑该怎样做才能实现上述效果呢，这就引出了 WSGI。</p>
<p><em>以下示例摘自<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832689740b04430a98f614b6da89da2157ea3efe2000" target="_blank" rel="noopener">廖雪峰的官方网站</a></em></p>
<p>WSGI:Web Server Gateway Interface.<br>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure>
<p>以上代码中application 函数接收两个参数，environ是一个包含所有HTTP请求信息的dict对象，start_response是一个发送HTTP响应的函数，该函数就是符合WSGI标准的一个HTTP处理函数。调用start_response()就发送了一个http header, http body 就是下文return 的数据。<br>利用python自带的 web server 加载上面这个application.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"><span class="comment"># 从wsgiref模块导入:</span></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"><span class="comment"># 导入我们自己编写的application函数:</span></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器，IP地址为空，端口是8000，处理函数是application:</span></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">8000</span>, application)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Serving HTTP on port 8000..."</span></span><br><span class="line"><span class="comment"># 开始监听HTTP请求:</span></span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<p>确保以上两个文件在同一个目录下，然后在命令行输入python server.py来启动WSGI服务器。</p>
<p><a name="B"></a></p>
<h2 id="探究-WSGI"><a href="#探究-WSGI" class="headerlink" title="探究 WSGI"></a>探究 WSGI</h2><p><em>以下内容摘自<a href="https://gist.github.com/nature-python/8954123" target="_blank" rel="noopener">wsgi和tornado.md</a></em></p>
<p>WSGI是为python语言定义的web服务器和web应用程序或框架之间的一种简单而实用的接口。wsgi是一个web组件的接口规范，它将web组件分为三类：server，middleware，application。接下来简单介绍下这三个组件：</p>
<ul>
<li>wsgi server :可以理解为一个符合wsgi规范的web server，接收request请求，封装一系列环境变量，按照wsgi规范调用注册的wsgi app，最后将response返回给客户端。</li>
<li>wsgi application :就是一个普通的callable对象，当有请求到来时，wsgi server会调用这个wsgi app。这个对象接收两个参数，通常为environ,start_response。environ可以理解为环境变量，跟一次请求相关的所有信息都保存在了这个环境变量中，包括服务器信息，客户端信息，请求信息。start_response是一个callback函数，wsgi application通过调用start_response，将response headers/status 返回给wsgi server。此外这个wsgi app会return 一个iterator对象 ，这个iterator就是response body。</li>
<li>wsgi middleware :可以简单地理解为对application的封装。通过封装实现一些公用的功能，如下示例用一个简单Dispatcher Middleware，用来实现URL 路由：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line">URL_PATTERNS= (</span><br><span class="line">    (<span class="string">'hi/'</span>,<span class="string">'say_hi'</span>),</span><br><span class="line">    (<span class="string">'hello/'</span>,<span class="string">'say_hello'</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_match</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        path = path.split(<span class="string">'/'</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> url,app <span class="keyword">in</span> URL_PATTERNS:</span><br><span class="line">            <span class="keyword">if</span> path <span class="keyword">in</span> url:</span><br><span class="line">                <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,environ, start_response)</span>:</span></span><br><span class="line">        path = environ.get(<span class="string">'PATH_INFO'</span>,<span class="string">'/'</span>)</span><br><span class="line">        app = self._match(path)</span><br><span class="line">        <span class="keyword">if</span> app :</span><br><span class="line">            app = globals()[app]</span><br><span class="line">            <span class="keyword">return</span> app(environ, start_response)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start_response(<span class="string">"404 NOT FOUND"</span>,[(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)])</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">"Page dose not exists!"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">"200 OK"</span>,[(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"kenshin say hi to you!"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">"200 OK"</span>,[(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"kenshin say hello to you!"</span>]</span><br><span class="line"></span><br><span class="line">app = Dispatcher()</span><br><span class="line"></span><br><span class="line">httpd = make_server(<span class="string">''</span>, <span class="number">8000</span>, app)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Serving on port 8000..."</span></span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<p>以上代码就已经有点web framework 的意思啦。由这个实例我们可以看到写一个基于wsgi的python web framework其实就是实现wsgi application部分和wsgi middleware 部分。其实，写一个python web framework 也是一件非常简单的事，见<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0014023080708565bc89d6ab886481fb25a16cdc3b773f0000" target="_blank" rel="noopener">廖雪峰的官方博客</a>。下面我们就探究一下业界常用的python web framework。而wsgi server部分我们待会再谈。</p>
<p><a name="C"></a></p>
<h2 id="探究-python-web-framework"><a href="#探究-python-web-framework" class="headerlink" title="探究 python web framework"></a>探究 python web framework</h2><p>翻看python 的wiki，我们发现关于python的web framework 以井喷的速度发展，各式各样的框架。截两张图，分别是主流的全栈框架和非全栈框架：</p>
<p>主流的全栈python web框架:<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160905python-full-stack.jpg" alt="full-stack"></p>
<p>这里要多说一句tornado框架，其实它不单是一个web框架，还是一个web服务器。作为Web框架，是一个轻量级的Web框架，类似于另一个Python web 框架Web.py，其拥有异步非阻塞IO的处理方式。作为Web服务器，Tornado有较为出色的抗负载能力，官方用nginx反向代理的方式部署Tornado和其它Python web应用框架进行对比，结果最大浏览量超过第二名近40%。见下表：<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160905tornado%20awesome.jpg" alt="tornado 比较"></p>
<p>主流的非全栈python web框架：<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/2016-0905python-non-full-stack.jpg" alt="non-full-stack"></p>
<p><a name="C"></a></p>
<h2 id="探究-python-web-server"><a href="#探究-python-web-server" class="headerlink" title="探究 python web server"></a>探究 python web server</h2><ul>
<li><p>Apache + modwsgi，配置安装比较繁琐，用的人越来越少。</p>
</li>
<li><p>Gunicorn，运行在UNIX平台上的python wsgi http server。</p>
</li>
<li><p>uWSGI,实现了uwsgi和WSGI两种协议的Web服务器，负责响应python 的web请求。此处提醒一下，uwsgi是一种uWSGI服务器自有的协议，它跟WSGI毛的关系都没有。关于他们的区别，<a href="http://www.itopers.com:8080/?p=586" target="_blank" rel="noopener">看这</a></p>
</li>
<li><p>Tornado,上文已介绍。</p>
</li>
</ul>
<p>附录一张图：<br><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160905-test-cgi-glue.png" alt="test"></p>
<p><a name="D"></a></p>
<h2 id="常见-python-web生产部署环境"><a href="#常见-python-web生产部署环境" class="headerlink" title="常见 python web生产部署环境"></a>常见 python web生产部署环境</h2><p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160905python-web-deploy.jpg" alt="python web deploy"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832689740b04430a98f614b6da89da2157ea3efe2000" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>
<p><a href="https://www.zhihu.com/question/21888077" target="_blank" rel="noopener">大家都是怎么部署python网站的</a></p>
<p><a href="http://www.itopers.com:8080/?p=586" target="_blank" rel="noopener">区分wsgi、uWSGI、uwsgi、php-fpm、CGI、FastCGI的概念</a></p>
<p><a href="https://www.zhihu.com/question/30560394" target="_blank" rel="noopener">使用了Gunicorn或者uWSGI,为什么还需要Nginx？</a></p>
<p><a href="https://www.peterbe.com/plog/fcgi-vs-gunicorn-vs-uwsgi" target="_blank" rel="noopener">fcgi vs. gunicorn vs. uWSGI</a></p>
<p><a href="http://stackoverflow.com/questions/11811434/what-is-the-difference-between-uwsgi-protocol-and-wsgi-protocol" target="_blank" rel="noopener">What is the difference between uwsgi protocol and wsgi protocol?</a></p>
<p><a href="http://www.letiantian.me/2015-09-10-understand-python-wsgi/" target="_blank" rel="noopener">理解Python WSGI</a></p>
<p><a href="https://wiki.python.org/moin/WebFrameworks" target="_blank" rel="noopener">Web Frameworks for Python</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/09/02/openstack-swift/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/openstack-swift/" itemprop="url">
                  openstack系列--swift
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-02T14:24:25+08:00">
                2016-09-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/09/02/openstack-swift/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/02/openstack-swift/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p>在学习一个新东西的时候，我们其实默认是带着问题去学习的。但当我们真正在卷帙繁多的互联网或者书籍里获取信息时。之前的问题往往就淡化了，反而更多的是跟着资料所给的思路去学习。这样有好处也有坏处，好处是我们不用费心去思考，而坏处也是如此，不用思考带来的后果就是这些信息虽然当时我们理解了，但很难在我们的脑海中建立知识图谱，比较容易遗忘。</p>
<p>所以以后我会在写文章的时候先把问题具象化，从自己问题的角度出发去寻找答案。比如本篇我们学习openstack的对象存储模块swift，出现在脑海中的第一个问题就是 <em>swift 是做什么用的？</em> 在解决了这个问题以后，我们知道<br>是做对象存储的，那么， <em>它是如何进行存储的？</em> ，这就是第二个问题。在了解了它的存储机制后，我们还想问的就是 <em>既然是存储，那么它的安全性机制是怎么做的？数据丢失了怎么办？</em> 。最后我们就要了解下 <em>swift 的具体使用</em> 以及 深入到代码层面 <em>源码的组织架构</em> 等。</p>
<p><a href="#A">swift什么用？ </a></p>
<p><a href="#B">swift中数据如何存储？ </a></p>
<p><a href="#C">swift中的安全机制</a></p>
<p><a href="#D">swift 如何使用？</a></p>
<p><a href="#E">swift 源码目录结构</a></p>
<p><a name="A"></a></p>
<h2 id="swift-什么用？"><a href="#swift-什么用？" class="headerlink" title="swift 什么用？"></a>swift 什么用？</h2><p>我们已经知道swift是openstack中负责对象存储的组件。自然而然的引出另一个问题，什么是对象存储？除了对象存储还有其他什么类型的存储，区别是什么？OK，接下来慢慢解决这些问题。</p>
<p>对象存储，有点类似于hashmap这种数据结构，我们可以通过key来获取/删除对应的value值。对象存储就是将对象数据作为一个逻辑单元存储起来，更多的操作是获取，删除。更新操作频率比较低。相应的，对象存储比较适合于存放静态数据或者更新频率比较低的大容量数据。比如一些多媒体数据，数据备份，虚拟机镜像等。</p>
<p>其他的存储类型还包括块存储，文件存储。</p>
<p>块存储通常提供的原始块设备，就是裸磁盘空间，比如磁盘阵列里面有2块硬盘，然后可以通过划逻辑盘、做Raid、或者LVM（逻辑卷）等种种方式逻辑划分出N个逻辑的硬盘，再采用映射的方式将这几个逻辑盘映射给主机使用。一些对实时性要求比较高的存储我们就得用块存储了，比如数据库。openstack中对应的组件为cinder。</p>
<p>文件存储就比较好理解了，我们常用的Windows操作系统就搭载了一套文件系统，提供文件存储。在分布式环境中，常用NFS协议，通过TCP/IP实现网络化存储，比如我们常用的NFS或者FTP服务器。</p>
<p><a name="B"></a></p>
<h2 id="swift中数据如何存储？"><a href="#swift中数据如何存储？" class="headerlink" title="swift中数据如何存储？"></a>swift中数据如何存储？</h2><p>首先看下swift的整体架构：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160902-swift_architecture.jpg" alt="swift_arvhitecture"></p>
<p>整体架构主要分为两部分，访问层（Access Tier）和存储层（Storage Node）。访问层最主要的有两部分，Proxy node 主要负责Http请求的的转发，还有一个负责用户身份的认证（Authentication）。可选的是一个负载均衡设备。</p>
<p>当一个Restful请求到来时，Proxy node 负责接受用户请求并转发给认证服务进行处理，认证通过后再转发给存储层进行数据的操作。在转发给存储层之前，如果启用缓存的话，首先会去缓存服务器检查是否命中，命中就不用去数据层了。</p>
<p>接下来我们看下存储层，存储层由一系列的存储节点组成。为了便于组织以及故障隔离，这些存储节点在物理上做了一些划分，比如根据地理位置的不同划分region,一个 region相当于一个数据中心，每个rigion内部有多个zone，zone可以理解为一组独立的存储节点。一个zone包含多个存储节点（storage node）,一个node里有多个Device(可以理解为磁盘)，一个Device包含多个Partition(可以理解为磁盘中文件系统上的一个目录)。</p>
<p>在每个Storage node 上存储的对象在逻辑上又分为三层：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160902swift-object-acchitectture.png" alt="swift 对象组织架构"></p>
<p>相应的，Storage node 中运行着三种对应的服务：</p>
<ul>
<li>Account Server :Account server 负责Account相关的一些服务，比如包含的Countainer列表，以及Account的元数据等。这些数据存储在一个SQLLite数据库中。</li>
<li>Countainer Server : 负责Countainer相关服务，比如包含的object列表，Countainer元数据。也存储在SQLlite数据库中。</li>
<li>Object Server : 提供对象数据的存取及相应的元数据服务，以二进制的形式存储在存储节点中，元数据以扩展属性的形式存储其中。因为对应的存储系统必须支持文件的扩展属性。</li>
</ul>
<p>由以上信息我们得知swift对象最终以二进制的形式存储在存储节点中，存储节点中并没有“路径”的概念，那么它最终是如何与物理位置映射的呢？swift提出了ring的概念，ring其实就是记录了存储对象与物理存储节点的映射关系，object，countainer，account都有与之对应的ring。proxy server接收到http请求时，先查找操作实体（object，countainer，account）对应的ring,根据ring确定他们在对应的服务器集群中的具体位置，并将对应的http请求转发给对应的节点上的server。</p>
<p>此处注意的是，对象寻址并非是渐进式的（即寻找某个object先寻找account，再寻找下面的countainer,再寻找对应的object），而是直接寻找（即寻找object ,直接ring就可以找到，同理寻找某个account，countainer也是如此）。</p>
<p>为什么叫ring呢？其实这跟那个映射算法有关，这个将数据映射在相应服务器集群上某个节点的算法叫一致性hash算法，关于该算法，可以花5分钟的时间了解下<a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">这篇文章</a></p>
<p>至于swift 中是如何具体实现该算法的就不详细叙述了。下图为大致架构图：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160904-openstack-swift-logic-architecture.png" alt="openstack-swift-logic-architecture"></p>
<p><a name="C"></a></p>
<h2 id="swift中的安全机制"><a href="#swift中的安全机制" class="headerlink" title="swift中的安全机制"></a>swift中的安全机制</h2><p>swift 中为了保证数据在损坏的情况下依然保证高可用，采用了增加副本的策略，每一个对象都会有若干个备份的副本（默认是三个），且存储在不同的zone里，这样，当某一个zone的对象数据不可用时，还可以启用其他zone里的副本。这样为了解决数据一致性的问题，swift开启了以下三个服务：</p>
<ul>
<li><p>Replicator: 负责检查数据与相应副本是否一致。如果出现数据不一致的情况，会将过时的数据更新，并负责将标记为删除的数据从磁盘上删除。</p>
</li>
<li><p>Auditor: 持续扫描磁盘检查Acount,Container和object数据的完整性，如果发现数据损坏，就会对相应的数据隔离，然后通过Replicator从其他节点上获取副本以恢复。</p>
</li>
<li><p>Updator: 在创建一个object的时候，需要对应的更新该object所在的container列表，以及再上层的account 列表，同理，创建container的时候也是如此。有时候这些更新操作因为相应的server繁忙而更新失败，swift会使用Updator服务继续处理这些失败的更新操作。</p>
</li>
</ul>
<p><a name="D"></a></p>
<h2 id="swift的使用"><a href="#swift的使用" class="headerlink" title="swift的使用"></a>swift的使用</h2><p>swift的使用跟其他openstack的组件使用一样都是通过restful API来提供服务。swift API主要提供了以下几种功能：</p>
<ul>
<li>对象存储 单个对象默认最大值是5GB，可以用户自己配置。</li>
<li>超过最大值对象的数据可以通过中间件进行上传，存储</li>
<li>对象压缩</li>
<li>对象删除</li>
</ul>
<p>swift API 的执行过程大致如下：swiftClient 将用户的命令转换为标准HTTP请求（如果是用户请求本身就是HTTP请求那么没有这一步）;paste deploy将请求路由到proxy-server WSGI Application;根据请求内容调用对应的Controller(AccountController,ContainerController或者ObjectController),该controller会将请求转发到特定的存储节点上的WSGI Server(Account Server,Container Server或Object Server);这些server接收到http请求并处理。</p>
<p><a name="E"></a></p>
<h2 id="swift-源码目录结构"><a href="#swift-源码目录结构" class="headerlink" title="swift 源码目录结构"></a>swift 源码目录结构</h2><p><img src="https://raw.githubusercontent.com/zhangchenchen/zhangchenchen.github.io/hexo/images/20160904-openstack-swift-sourcecode.jpg" alt="swift source code"></p>
<ul>
<li>bin: 主要是一些启动脚本，工具脚本。比如proxy-server负责启动proxy server，swift-ring-builder 用来创建ring。</li>
<li>swift：swift的核心代码。其子目录account,container,obj,proxy分别对应相应的服务的具体实现。common子目录是被多个组件共用的公共代码。</li>
<li>etc:配置文件模板</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://book.douban.com/subject/26374647/" target="_blank" rel="noopener">openstack 设计与实现</a></p>
<p><a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">五分钟了解一致性hash</a></p>
<p><a href="https://github.com/openstack/swift" target="_blank" rel="noopener">swift github</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/08/31/python-requests/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/31/python-requests/" itemprop="url">
                  python库系列--requests 与 刷票
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-31T10:24:25+08:00">
                2016-08-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/08/31/python-requests/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/31/python-requests/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">关于刷票的若干思考 </a></p>
<p><a href="#B">requests 引出 </a></p>
<p><a href="#C">requests 基本用法</a></p>
<p><a href="#D">requests 高级用法</a></p>
<p><a name="A"></a></p>
<h2 id="关于刷票的若干思考"><a href="#关于刷票的若干思考" class="headerlink" title="关于刷票的若干思考"></a>关于刷票的若干思考</h2><p>前两天同学让我帮他去一个网站帮他刷票，就顺手写了一个小程序，整理一下关于刷票的若干思考：<br>其实应付普通的投票机制非常简单，只要懂点http的相关知识就可以搞定，原理就是构造相应的HTTP请求。一般来说，为了防止刷票，都会有以下几种防刷票策略：</p>
<ul>
<li><p>限制IP : 相应的对策就是伪造IP。要想伪造IP的话首先要知道后端服务器程序是怎么获取IP的。至少有三个HTTP HEAD可以获取用户端IP，REMOTE_ADDR、HTTP_VIA、HTTP_FORWARDED_FOR 。REMOTE_ADDR是WEB服务器获取的用户IP值，也就是最终的外网IP，但它的重复值太多，所以不能作为唯一判断标志。 HTTP_VIA是倒数第二个代理服务器/网关的IP。 HTTP_FORWARDED_FOR是所有网关和你自己的IP列表。大部分服务端程序都是用HTTP_FORWARDED_FOR来获取IP。这样我们就可以通过修改HTTP_FORWARDED_FOR来达到伪造IP的目的。</p>
</li>
<li><p>限制网页来源 : 修改 http header中的refer。</p>
</li>
<li><p>限制 user-agent : 修改 http header中的 user-agent。</p>
</li>
<li><p>限制cookie : 修改 http header中的 cookie</p>
</li>
<li><p>限制登录后才可以投票 :模拟登录</p>
</li>
<li><p>验证码验证 : 简单的验证码可以通过OCR识别技术，增加干扰策略的验证码就比较复杂了，不予讨论。</p>
</li>
</ul>
<p>当然，其实防刷票机制不只是上面简单的几种，一般来说比较安全的网站都会制定一些策略，比如IP可疑就增加验证码难度，设定黑白名单等。</p>
<p><a name="B"></a></p>
<h2 id="requests-引出"><a href="#requests-引出" class="headerlink" title="requests 引出"></a>requests 引出</h2><p>因为写上面的那个小程序用的是requests库。就简单的学习了一下这个库。<br>python有自己的标准网络库，urllib,urllib2。但这两个库用着都不是特别的顺畅，requests 库的出现让人们眼前一亮，官网的declare:HTTP for Humans 。强调人性化。</p>
<p><a name="C"></a></p>
<h2 id="requests-基本用法"><a href="#requests-基本用法" class="headerlink" title="requests 基本用法"></a>requests 基本用法</h2><p>requests包要完成的内容无非就是发送和接收http请求。接下来我们就从发送请求和接收请求两方面讨论下它的基本使用。</p>
<ul>
<li>发送请求 ：首先最简单的就是常用的get，post等发送HTTP请求类型，requests是这样发送的：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</span><br><span class="line">r = requests.post(<span class="string">"http://httpbin.org/post"</span>)</span><br><span class="line">r = requests.put(<span class="string">"http://httpbin.org/put"</span>)</span><br><span class="line">r = requests.delete(<span class="string">"http://httpbin.org/delete"</span>)</span><br><span class="line">r = requests.head(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">r = requests.options(<span class="string">"http://httpbin.org/get"</span>)</span><br></pre></td></tr></table></figure>
<p> 对于 get 请求，我们可以通过添加params添加关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">param = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=param)</span><br></pre></td></tr></table></figure>
<p> 对于post请求，我们可以通过data参数来模拟提交表单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">param = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, data=param)</span><br></pre></td></tr></table></figure>
<p> 还可以通过 headers参数定制我们发送的请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> my_headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'Accept'</span> : <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span> : <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span> : <span class="string">'zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4'</span></span><br><span class="line">&#125;</span><br><span class="line"> r = requests.get(<span class="string">"http://httpbin.org/get"</span>, headers=my_headers)</span><br></pre></td></tr></table></figure>
<p> 除此之外，还有timeout，cookies参数来设置响应时间，cookie。</p>
<ul>
<li>相应内容 ： 任何时候调用 requests.*() 你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦requests得到一个从服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</span><br><span class="line"></span><br><span class="line">print(r.text) <span class="comment"># 字符形式，可以自己设置编码</span></span><br><span class="line"></span><br><span class="line">print(r.content) <span class="comment"># 二进制形式</span></span><br><span class="line"></span><br><span class="line">print(r.json()) <span class="comment"># json形式,requests 中有一个内置的 JSON 解码器,处理 JSON 数据。</span></span><br><span class="line"></span><br><span class="line">print(r.raw()) <span class="comment"># 原始套接字形式</span></span><br></pre></td></tr></table></figure>
<p><a name="D"></a></p>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ul>
<li>会话对象：http是无状态的，为了能够获取用户登录状态，一般服务器会用一个sessionId放在cookie中。用户发送的请求也包含这个sessionId，这些工作由浏览器来做。而requests也实现了类似功能。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/sessioncookie/123456789'</span>)</span><br><span class="line">r = s.get(<span class="string">"http://httpbin.org/cookies"</span>)</span><br><span class="line"></span><br><span class="line">print(r.text)</span><br><span class="line"> <span class="comment">#'&#123;"cookies": &#123;"sessioncookie": "123456789"&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SSL 证书验证<br>Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。要想检查某个主机的 SSL 证书，可以使用 verify 参数:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">'https://github.com'</span>, verify=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>代理<br>利用proxies 参数来配置请求 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,</span><br><span class="line">  <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">"http://example.org"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">requests quickstart</a></p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html" target="_blank" rel="noopener">requests advance </a></p>
<p><a href="http://liam0205.me/2016/02/27/The-requests-library-in-Python/" target="_blank" rel="noopener">Python HTTP 库：requests 快速入门</a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhangchenchen.github.io/2016/08/29/shell-set/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="pekingzcc">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Solar">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Solar" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/29/shell-set/" itemprop="url">
                  shell脚本系列--set 与 unset
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-29T14:24:25+08:00">
                2016-08-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/08/29/shell-set/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/29/shell-set/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p><a href="#A">命令用途 </a></p>
<p><a href="#B">常用命令参数 </a></p>
<p><a href="#C">使用示例</a></p>
<p><a name="A"></a></p>
<h2 id="命令用途"><a href="#命令用途" class="headerlink" title="命令用途"></a>命令用途</h2><p>set 主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号”+”和”-“的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用declare命令以 变量名=值 的格式进行定义即可。</p>
<p>unset 用于删除已定义的shell变量（包括环境变量）和shell函数。unset命令不能够删除具有只读属性的shell变量和环境变量。</p>
<p><a name="B"></a></p>
<h2 id="常用命令参数"><a href="#常用命令参数" class="headerlink" title="常用命令参数"></a>常用命令参数</h2><p>set常用参数</p>
<ol>
<li><p>-a  标示已修改的变量，以供输出至环境变量。</p>
</li>
<li><p>-b 使被中止的后台程序立刻回报执行状态。</p>
</li>
</ol>
<p>unset 常用参数</p>
<ol>
<li><p>-f 仅删除函数</p>
</li>
<li><p>-v 仅删除变量</p>
</li>
</ol>
<p><a name="C"></a></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>set 示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">declare</span> mylove=<span class="string">'Visual C++'</span> <span class="comment">#定义新环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -a mylove <span class="comment">#设置为环境变量</span></span><br><span class="line"></span><br><span class="line">env | grep mylove <span class="comment">#显示环境变量值</span></span><br></pre></td></tr></table></figure>
<p>unset 示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">unset</span> -v mylove <span class="comment">#删除指定的环境变量</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://man.linuxde.net/unset" target="_blank" rel="noopener">Linux unset</a></p>
<p><a href="http://man.linuxde.net/set" target="_blank" rel="noopener">linux set </a></p>
<p><strong><em>本篇文章由<a href="https://zhangchenchen.github.io/">pekingzcc</a>采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可,转载请注明。</em></strong></p>
<p> <strong><em>END</em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="pekingzcc" />
          <p class="site-author-name" itemprop="name">pekingzcc</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">101</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangchenchen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pekingzcc</span>
</div>


<div class="powered-by">
  powered by <a class="theme-link" href="https://hexo.io">Hexo</a> 
</div>

<div class="theme-info">
  theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'pekingzcc';
      var disqus_identifier = 'page/9/index.html';

      var disqus_title = "";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      

    </script>
  









  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
